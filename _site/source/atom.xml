<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[]]></title>
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2011-11-11T08:18:32-07:00</updated>
  <id>/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Intro to Java & Play! on Heroku in Mountain View]]></title>
    <link href="/source/2011/11/09/intro-to-java-play-on-heroku-in-mountain-view.html"/>
    <updated>2011-11-09T00:00:00-07:00</updated>
    <id>/source/2011/11/09/intro-to-java-play-on-heroku-in-mountain-view</id>
    <content type="html"><![CDATA[On November 10, 2011 <a href="https://twitter.com/cloudysan">Sandeep Bhanot</a> and I will be presenting an <a href="http://www.meetup.com/HandsOnProgrammingEvents/events/38029722/">Introduction to Java & Play Framework on Heroku</a> at the Hacker Dojo in Mountain View.  Space is almost gone, so <a href="http://www.meetup.com/HandsOnProgrammingEvents/events/38029722/">register now</a>!  Hope to see you there.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java, Play! & Scala on Heroku at the Dallas JUG]]></title>
    <link href="/source/2011/11/08/java-play-scala-on-heroku-at-the-dallas-jug.html"/>
    <updated>2011-11-08T00:00:00-07:00</updated>
    <id>/source/2011/11/08/java-play-scala-on-heroku-at-the-dallas-jug</id>
    <content type="html"><![CDATA[On Wednesday November 9, 2011 I'll be presenting "Running Java, Play! and Scala Apps on the Cloud" at the <a href="http://javamug.org/">Dallas Java User Group</a>.  If you are in the Dallas area then I hope to see you there!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Video: Play Framework Scala Apps on the Cloud]]></title>
    <link href="/source/2011/10/25/video-play-framework-scala-apps-on-the-cloud.html"/>
    <updated>2011-10-25T00:00:00-06:00</updated>
    <id>/source/2011/10/25/video-play-framework-scala-apps-on-the-cloud</id>
    <content type="html"><![CDATA[Last week I posted the steps to <a href="http://www.jamesward.com/2011/10/19/running-play-framework-scala-apps-on-heroku">getting started with Play Framework and Scala</a>.  Here is a video that walks through those steps in real-time:
<iframe width="640" height="480" src="http://www.youtube.com/embed/SHA5aITE7Ak?hd=1" frameborder="0" allowfullscreen></iframe>

Let me know if you have any questions.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up Play Framework Apps in IntelliJ IDEA]]></title>
    <link href="/source/2011/10/24/setting-up-play-framework-apps-in-intellij-idea.html"/>
    <updated>2011-10-24T00:00:00-06:00</updated>
    <id>/source/2011/10/24/setting-up-play-framework-apps-in-intellij-idea</id>
    <content type="html"><![CDATA[JetBrains <a href="http://blogs.jetbrains.com/idea/2011/10/play-with-intellij-idea-eap-build-110187/">just announced</a> that they have <a href="http://confluence.jetbrains.net/display/IDEADEV/IDEA+11+EAP">posted a new EAP release</a> of IntelliJ IDEA that supports <a href="http://www.playframework.org">Play Framework</a> apps!  Here is a quick video I recorded that shows how to get IntelliJ setup with a Play app:
<iframe width="640" height="480" src="http://www.youtube.com/embed/RRykeXRQKIU?hd=1" frameborder="0" allowfullscreen></iframe>

Thanks JetBrains!  This is awesome stuff!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Play Framework + Scala Apps on Heroku]]></title>
    <link href="/source/2011/10/19/running-play-framework-scala-apps-on-heroku.html"/>
    <updated>2011-10-19T00:00:00-06:00</updated>
    <id>/source/2011/10/19/running-play-framework-scala-apps-on-heroku</id>
    <content type="html"><![CDATA[Building <a href="http://scala.playframework.org/">Play Framework apps with Scala</a> is all the rage right now.  And for good reason...  It's never been easier to build and deploy JVM-based web apps!  Lets walk through how to build a Play app with Scala and then deploy it on the cloud with Heroku.

Step 1) <a href="http://www.playframework.org/download">Install the Play Framework</a> (make sure you have at least version 1.2.3)

Step 2) Install the Play Scala module:
<pre lang="bash">
play install scala
</pre>

Step 3) Create a new Play app with Scala support:
<pre lang="bash">
play new playwithscala --with scala
</pre>

Step 4) Start the app:
<pre lang="bash">
cd playwithscala
play run
</pre>

Step 5) Open the app in your browser:
<a href="http://localhost:9000">http://localhost:9000</a>

That was easy!  Lets spice this up a bit before we deploy it on Heroku by adding a custom model, view, and controller.

Step 1) Create a new <em>app/models/Widget.scala</em> file containing:
<pre lang="scala">
package models

case class Widget(id: Int, name: String)
</pre>

Step 2) Create a new <em>app/views/Widget/list.scala.html</em> file containing:
<pre lang="scala">
@(widgets: Vector[models.Widget])

<!DOCTYPE html>
<html>
    <body>
        @widgets.map { widget => 
            Widget @widget.id = @widget.name</br>
        }
    </body>
</html>
</pre>

Step 3) Create a new <em>app/controllers/WidgetController.scala</em> file containing:
<pre lang="scala">
package controllers

import play._
import play.mvc._

object WidgetController extends Controller {

    import views.Widget._
    import models.Widget

    def list = {
        val widget1 = Widget(1, "The first Widget")
        val widget2 = Widget(2, "A really special Widget")
        val widget3 = Widget(3, "Just another Widget")
        html.list(Vector(widget1, widget2, widget3))
    }

}
</pre>

Step 4) Test out the new code by going to:
<a href="http://localhost:9000/WidgetController/list">http://localhost:9000/WidgetController/list</a>

It works!  And we didn't even need to reload the server!  But lets clean up that URL a bit.  Edit the <em>conf/routes</em> file and change "Application.index" to "WidgetController.list":
<pre lang="something">
GET     /                                       WidgetController.list
</pre>

Now load the new URL:
<a href="http://localhost:9000/widgets/list">http://localhost:9000/</a>

That was easy but now we want to show our friends.  So lets deploy it on Heroku.

Step 1) Install the Heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>

Step 2) Login to Heroku from the command line:
<pre lang="bash">
heroku auth:login
</pre>

Step 3) Heroku uses git for application upload, so create a .gitignore file containing:
<pre lang="something">
/modules
/tmp
</pre>

Step 4) Create a git repo, add the files to it, and commit them:
<pre lang="bash">
git init
git add .
git commit -m init
</pre>

Step 5) Create the new application on Heroku:
<pre lang="bash">
heroku create -s cedar
</pre>

This provisions a new application on Heroku and assigns a random name / URL to the app.

Step 6) Deploy the application:
<pre lang="bash">
git push heroku master
</pre>

The application will now be assembled and deployed on Heroku.

Step 7) Open the application in the browser:
<pre lang="bash">
heroku open
</pre>

Tada!  Your Play + Scala app is now running on the cloud!

At JavaOne I showed this to Bill Venners (creator of <a href="http://www.scalatest.org/">ScalaTest</a>).  He then moved the scalatest.org website (a Play + Scala app) to Heroku!  Cool stuff!

Let me know if you have any questions.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Scala: Function Literals]]></title>
    <link href="/source/2011/10/17/learning-scala-function-literals.html"/>
    <updated>2011-10-17T00:00:00-06:00</updated>
    <id>/source/2011/10/17/learning-scala-function-literals</id>
    <content type="html"><![CDATA[I've gradually been learning Scala over the past few months and I really have been enjoying it.  For me Scala is like Shakespeare.  It seems familiar and totally foreign at the same time.  I don't enjoy Shakespeare plays nearly as much as someone who has taken the time to learn the language of Shakespeare.  Some have interpreted Scala being "familiar yet totally foreign" as Scala being "hard" but I'd say it's just different.  With Scala there is probably more about programming that I need to unlearn than to learn.  My perspectives on programming languages have been shaped by the ones I've used most (Java, ActionScript, etc).  And now my perspecives are being reshaped.  It might take some time and work but I believe that using Scala will soon be very enjoyable for me.

Ok, enough fluff lets see some code!

My friend <a href="http://www.mslinn.com/blog/">Mike Slinn</a> and I have been learning <a href="https://github.com/jdegoes/blueeyes">BlueEyes</a> - a lightweight Scala web 3.0 framework.  We encountered a piece of Scala that seemed strange and unfamiliar to us:
<pre lang="scala">
get { request =>
  // do something
}
</pre>

To a Java developer like me this was pretty foreign.  I was able to understand this after I encountered <em>Function Literals</em> in the free <a href="http://typesafe.com/resources/scala-for-the-impatient">Scala for the Impatient</a> book.  So let me break down what is happening here with another example.  Lets start with writing a regular function that takes a <em>Char</em> parameter and returns a <em>Boolean</em> if the provided <em>Char</em> was the letter "l":
<pre lang="scala">
def lls(p: Char): Boolean = { p == 'l' }
</pre>

This is a pretty straight forward (albeit slightly verbose) function definition.  Oh, and I should mention that if you <a href="http://www.scala-lang.org/downloads">download Scala</a> and run the REPL (a command line interpreter), then you can actually try this code yourself.  To start the Scala REPL just run the "scala" command.

Ok, lets test out that function:
<pre lang="scala">
lls('p') // outputs false
lls('l') // outputs true
</pre>

That should all be somewhat familiar looking for a Java developer.  But here is where things begin to look more foreign.  The <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.StringOps">StringOps</a> class in Scala has a <em>count</em> method that takes something very peculiar looking.  From the ScalaDoc:
<pre lang="scala">
def count (p: (Char) ⇒ Boolean): Int
</pre>

That is saying that <em>count</em> takes a function as an argument.  Scala is this wonderful blend of Object Oriented and Functional so this is instantly strange to the Java developer in me.  In this case the function that <em>count</em> is taking must have a single parameter of type <em>Char</em> and then return a <em>Boolean</em>.  So lets try to pass the <em>lls</em> function to <em>count</em> on a <em>StringOps</em> instance.  Somehow with Scala's Type Inference system we can just use a regular double-quoted <em>String</em> and Scala will figure out that we need a <em>StringOps</em> instead.  So let's create a <em>StringOps</em> object and call count on it passing it the <em>lls</em> function:
<pre lang="scala">
"Hello".count(lls) // outputs 2
</pre>

I could have assigned "Hello" to a variable and done it that way but opted to just make the <em>count</em> call without assigning it.  So <em>count</em> correctly took the <em>lls</em> function and used it to count the number of "l" <em>Chars</em> in the <em>String</em> (or <em>SpringOps</em>).  That all works as expected.

But, there is another (prettier) way to do the same thing:
<pre lang="scala">
"Hello" count lls // outputs 2
</pre>

We can drop the dot operator and parenthesis and everything still works.  But there is another way...  Instead of referencing a function we can just pass the function definition directly into the count method:
<pre lang="scala">
"Hello" count { p:Char => p == 'l' } // outputs 2
</pre>

This is a <strong>Function Literal</strong> - or as Dick Wall tells me, a predicate in this case since it returns a <em>Boolean</em>.  A Function Literal is a short way to define a function that takes only one parameter and returns what is needed by whatever the function is being passed to.  In this case the function parameter is still a Char with an identifier of "p" and the function body simply compares "p" with the 'l' <em>Char</em>.  In Scala the value of the last statement in a function is returned.  So the <em>Boolean</em> is returned from the function.  That type is inferred.  And the <em>Char</em> type declaration on "p" could have been left off and inferred making it:
<pre lang="scala">
"Hello" count { p => p == 'l' } // outputs 2
</pre>

Now that code I started with is making a lot more sense!

But it doesn't stop there.  With Scala we can be even more concise:
<pre lang="scala">
"Hello" count { _ == 'l' } // still outputs 2
</pre>

Now I must admit that I haven't really learned what that "_" thing does.  So I don't totally understand this code yet.  But like learning to understand Shakespeare we have to take it one step at a time.  I will leave that to another day and maybe another blog post.  I hope this was helpful for other Scala noobs.  Let me know what you think and if you have any questions.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heroku Java User Group Tour Part 1: Los Angeles and Salt Lake City]]></title>
    <link href="/source/2011/10/10/heroku-java-user-group-tour-part-1-los-angeles-and-salt-lake-city.html"/>
    <updated>2011-10-10T00:00:00-06:00</updated>
    <id>/source/2011/10/10/heroku-java-user-group-tour-part-1-los-angeles-and-salt-lake-city</id>
    <content type="html"><![CDATA[This week I'm starting a Java User Group tour where I'll be travelling to JUGs around the US (or maybe world).  On the tour I'll be giving a talk about <strong>Running Java, Play! and Scala Apps on the Cloud</strong>.  Here is the description:
<blockquote>Heroku is a Polyglot Cloud Application Platform that makes it easy to deploy Java, Play! and Scala apps on the cloud. Deployment is as simple as doing a "git push". This session will teach you how to instantly deploy and scale Java, Play! and Scala apps on Heroku.</blockquote>

I'm still scheduling JUGs but here are the first two I'll be doing:
<ul>
<li><a href="http://www.lajug.org/index.html">Los Angeles JUG - October 11</a></li>
<li><a href="http://www.ujug.org/">Utah / Salt Lake City / Murray JUG - October 20</a></li>
</ul>

There will be more to come and if you'd like this talk at your local Java User Group, let your leader know and have them email me: jw &lt;at&gt; heroku &lt;dot&gt; com

Hopefully see you at your local JUG!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heroku is Hiring]]></title>
    <link href="/source/2011/10/07/heroku-is-hiring.html"/>
    <updated>2011-10-07T00:00:00-06:00</updated>
    <id>/source/2011/10/07/heroku-is-hiring</id>
    <content type="html"><![CDATA[It's been four months since I started working at Heroku as a Developer Evangelist.  Now it is clear to me that I got really lucky.  Heroku is a top-notch place to work.  The product is sexy.  The people are all rock stars.  Heroku is owned by Salesforce.com so there is the stability of a large company but the start-up culture remains in place.

Heroku is looking to hire <a href="http://jobs.heroku.com/">lots of people (engineers, marketing, etc)</a> but of particular interest to my readers might be the <a href="http://heroku.theresumator.com/apply/F1VGjh/Java-Developer-Evangelist.html">Java Developer Evangelist</a> position.  Come work with me to help educate Java developers about Heroku!

BTW: Check out how the application asks for your GitHub URL.  I love this place!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started with Scala on Heroku]]></title>
    <link href="/source/2011/10/03/getting-started-with-scala-on-heroku.html"/>
    <updated>2011-10-03T00:00:00-06:00</updated>
    <id>/source/2011/10/03/getting-started-with-scala-on-heroku</id>
    <content type="html"><![CDATA[Over the past year I've been gradually learning Scala and I think it's fantastic!  So I'm incredibly excited that <a href="http://blog.heroku.com/archives/2011/10/3/scala/">Scala now runs on Heroku</a>!  Of course you can use the standard <a href="http://www.jamesward.com/2011/08/25/heroku-adds-java-support">Java on Heroku</a> / Maven method of running Scala on Heroku.  But as of today you can also use <a href="https://github.com/harrah/xsbt">sbt</a> (the Scala Build Tool) to run Scala apps on Heroku.  If you are new to Heroku, it is a Polyglot Cloud Application Platform.  Put very simply:

<strong>Heroku = Polyglot + Platform as a Service (PaaS) + Cloud Components</strong>

If you want to try out Scala on Heroku, here are a few quick steps to get you started:
<ol>
<li><a href="http://heroku.com/signup">Create a Heroku account</a></li>
<li>Install the Heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>.</li>
<li>Install <a href="http://git-scm.com/">git</a> and setup your SSH key</li>
<li>Install <a href="https://github.com/harrah/xsbt/wiki/Setup">sbt</a> 0.11.0</li>
<li>
Login to Heroku from the command line:
<pre lang="bash">heroku auth:login</pre>
</li>
<li>Create a file named <em>build.sbt</em> containing:
<pre lang="scala">
scalaVersion := "2.9.1"

{
  val stage = TaskKey[Unit]("stage", "Prepares the project to be run, in environments that deploy source trees rather than packages.")
  stage in Compile := {}
}
</pre>
This adds the "stage" task which is used for the build on Heroku.
</li>
<li>Create a <em>project/build.properties</em> file containing:
<pre lang="something">
sbt.version=0.11.0
</pre>
This tells sbt which version of sbt to use.
</li>
<li>Create a very simple Scala app in <em>src/main/scala/Hello.scala</em> containing:
<pre lang="scala">
object Hello extends App {
  println("hello, world")
}
</pre>
</li>
<li>Test the app locally by running:
<pre lang="bash">
sbt run
</pre>
You should see something like:
<pre lang="bash">
[info] Set current project to default-0c17d0 (in build file:/home/jamesw/projects/helloscala/)
[info] Running Hello 
hello, world
[success] Total time: 1 s, completed Sep 7, 2011 4:17:01 AM
</pre>
</li>
<li>Create a <em>.gitignore</em> file containing:
<pre lang="something">
target
project/boot
project/target
</pre>
</li>
<li>Create a git repo, add the files to it, and commit them:
<pre lang="bash">
git init
git add .
git commit -m init
</pre>
</li>
<li>Create a new app on Heroku using the Cedar stack:
<pre lang="bash">
heroku create -s cedar
</pre>
</li>
<li>Upload your app to Heroku using git:
<pre lang="bash">
git push heroku master
</pre>
</li>
<li>Run the app on Heroku:
<pre lang="bash">
heroku run "sbt run"
</pre>
Voilà!  You just ran Scala on the Cloud!
</li>
</ol>

You can get the full code for this project on github:
<a href="https://github.com/jamesward/helloscala">https://github.com/jamesward/helloscala</a>

That was a very simple example to get you started.  Visit the <a href="http://devcenter.heroku.com/tags/scala">Heroku Dev Center</a> to continue learning about how to use Scala on Heroku.  And let me know if you have any questions.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Concurrency with Akka: Composing Futures]]></title>
    <link href="/source/2011/09/21/java-concurrency-with-akka-composing-futures.html"/>
    <updated>2011-09-21T00:00:00-06:00</updated>
    <id>/source/2011/09/21/java-concurrency-with-akka-composing-futures</id>
    <content type="html"><![CDATA[I've been intrigued by <a href="http://akka.io/">Akka</a> for a while but finally I was able to take it for a spin.  The first thing I wanted to learn was how to compose Futures.  Composing Futures provides a way to do two (or more) things at the same time and then wait until they are done.  Typically in Java this would be done with a <code><del datetime="2011-09-23T22:23:58+00:00">CyclicBarrier</del></code> <code>ExecutorService</code>.  <del datetime="2011-09-23T22:23:58+00:00">But setting up the code to manage a <code>CyclicBarrier</code> is challenging.</del>  <em>(UPDATE: Turns out it's not very challenging, I just didn't know how to do it.  I'm new to concurrency in Java and didn't find much on this stuff - probably because I didn't even know what to search for.)</em>  So I put together a quick little demo that shows how to do the same thing with Futures in Akka.

All of the code for this demo is on github:
<a href="http://github.com/jamesward/AkkaFun">http://github.com/jamesward/AkkaFun</a>

First I setup a Gradle build that pulls in the Akka dependency and will allow me to easily launch the demo app.  Here is the <code>build.gradle</code> file:

<pre lang="groovy">
apply plugin:"application"
mainClassName = "com.jamesward.akkafun.SimpleFutures"

repositories {
    mavenCentral()
}

dependencies {
  compile "se.scalablesolutions.akka:akka-actor:1.2-RC6"
}
</pre>

For this demo I also wanted to increase the Akka timeout to 1 minute (the default is 5 seconds).  To do this I created a <code>src/main/resources/akka.conf</code> file containing:
<pre lang="json">
akka {
    actor {
        timeout = 60
    }
}
</pre>

I then setup a <code>Callable</code> class that does some work and then returns it's result.  For this example the work is just to pause for a random amount of time and the result is the amount of time it paused for.  Here is the <code>src/main/java/com/jamesward/akkafun/RandomPause.java</code> file:
<pre lang="java">
package com.jamesward.akkafun;

import java.util.concurrent.Callable;

public class RandomPause implements Callable<Long>
{

    private Long millisPause;

    public RandomPause()
    {
        millisPause = Math.round(Math.random() * 8000) + 2000; // 2,000 to 10,000
        System.out.println(this.toString() + " will pause for " + millisPause + " milliseconds");
    }

    public Long call() throws Exception
    {
        Thread.sleep(millisPause);
        System.out.println(this.toString() + " was paused for " + millisPause + " milliseconds");
        return millisPause;
    }
}
</pre>

I used a simple Java app to compose the <code>RandomPause</code> futures.  Here is the <code>src/main/java/com/jamesward/akkafun/SimpleFutures.java</code> file:

<pre lang="java">
package com.jamesward.akkafun;

import java.util.ArrayList;
import java.util.List;

import akka.dispatch.Future;
import static akka.dispatch.Futures.future;
import static akka.dispatch.Futures.sequence;

public class SimpleFutures
{
    public static void main(String[] args)
    {
        List<Future<Long>> futures = new ArrayList<Future<Long>>();

        System.out.println("Adding futures for two random length pauses");

        futures.add(future(new RandomPause()));
        futures.add(future(new RandomPause()));

        System.out.println("There are " + futures.size() + " RandomPause's currently running");

        // compose a sequence of the futures
        Future<Iterable<Long>> futuresSequence = sequence(futures);

        // block until the futures come back
        Iterable<Long> results = futuresSequence.get();

        System.out.println("All RandomPause's are complete");

        Long totalPause = 0L;
        for (Long result : results)
        {
            System.out.println("One pause was for " + result + " milliseconds");
            totalPause += result;
        }

        System.out.println("Total pause was for " + totalPause + " milliseconds");
    }
}
</pre>

Lets walk through the pieces of this.

First, a place to store the list of Futures is created:
<pre lang="java">
List<Future<Long>> futures = new ArrayList<Future<Long>>();
</pre>

The <code>Future</code> object is parameterized with the type of result the <code>Future</code> will return - a <code>Long</code> in this case. (I'm using the Akka <code>Future</code> not the regular Java <code>Future</code>.)

The <code>Futures.future</code> static method is used to create a new <code>Future</code> from an instance of a <code>Callable</code> object and that Future is added to the list of Futures:

<pre lang="java">
futures.add(future(new RandomPause()));
</pre>

In this case a <code>RandomPause</code> instance is created.  This is done twice to add two futures to the list.

You may have noticed in <code>RandomPause</code> that <code>Callable</code> is parameratized with a <code>Long</code>:

<pre lang="java">
public class RandomPause implements Callable<Long>
</pre>

The result of the work (the <code>call</code> method) returns a <code>Long</code> so the <code>Callable</code> and the <code>Future</code> must be parameratized with a Long.

In order to compose the futures together, another <code>Future</code> will be created containing the sequence of the list of futures:

<pre lang="java">
Future<Iterable<Long>> futuresSequence = sequence(futures);
</pre>

The <code>Future</code> is parameratized with an <code>Iterable</code> which is parameratized with a Long to match the result of the <code>Callable</code>.  The <code>Futures.sequence</code> method is used to create the new <code>Future</code> from the list of Futures.

Using the <code>futuresSequence</code> the applicaiton can wait (or block) until the <code>RandomPause</code> objects in <code>futures</code> list have all returned, or the timeout was reached:

<pre lang="java">
Iterable<Long> results = futuresSequence.get();
</pre>

Each result is now available.  That seems too easy!  Thanks Akka!

Let me know if you have any questions about this example.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Video: Running Java Web Apps on the Cloud]]></title>
    <link href="/source/2011/09/14/video-running-java-web-apps-on-the-cloud.html"/>
    <updated>2011-09-14T00:00:00-06:00</updated>
    <id>/source/2011/09/14/video-running-java-web-apps-on-the-cloud</id>
    <content type="html"><![CDATA[Here is a quick screencast that shows how to instantly deploy Java web applications on the cloud with Heroku.

<iframe width="640" height="510" src="http://www.youtube.com/embed/PqLkjJvEMko?hd=1" frameborder="0" allowfullscreen></iframe>

If you want more than a quick introduction check out a <a href="http://vimeo.com/28803302">recording of my presentation at JavaZone</a>.  And visit <a href="http://www.heroku.com/java">heroku.com/java</a> for more details on how to get started running Java apps on Heroku.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flex AOP and Puzzlers at Flash Camp Italy]]></title>
    <link href="/source/2011/09/14/flex-aop-and-puzzlers-at-flash-camp-italy.html"/>
    <updated>2011-09-14T00:00:00-06:00</updated>
    <id>/source/2011/09/14/flex-aop-and-puzzlers-at-flash-camp-italy</id>
    <content type="html"><![CDATA[Next week I'll be speaking at the <a href="http://www.flex-developers.org/2011/08/flash-camp-italy-23-sept-2011/">Flex Camp in Rimini, Italy</a>.  On September 23, Mike Labriola and I will be doing two sessions.  First is "Planet of the AOPs" where we will show how Aspect Oriented Programming can be implemented in Flex using runtime bytecode modification.  Mike and I will also be doing a little "Flex Puzzlers" session where you will discover some very peculiar things about Flex and Flash Player.  It's going to be a blast and I hope to see you there!  Also, there will be a raffle for a copy of Creative Suite 5.5 and a Playbook.  So go <a href="http://flashcampitaly.eventbrite.com/">sign up NOW</a>!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sending Play Framework File Uploads to Amazon S3]]></title>
    <link href="/source/2011/09/13/sending-play-framework-file-uploads-to-amazon-s3.html"/>
    <updated>2011-09-13T00:00:00-06:00</updated>
    <id>/source/2011/09/13/sending-play-framework-file-uploads-to-amazon-s3</id>
    <content type="html"><![CDATA[A couple of questions [<a href="http://stackoverflow.com/questions/7314106/handling-file-uploads-in-play-framework-on-heroku/7334400">1</a>, <a href="http://stackoverflow.com/questions/7258965/store-blob-in-heroku-or-similar-cloud-services">2</a>] on StackOverflow.com led me to look into how we can send file uploads in a Play Framework application to <a href="http://aws.amazon.com/s3/">Amazon S3</a> instead of the local disk.  For applications running on Heroku this is especially important because the local disk is not persistent.  Persistent disk storage makes it hard to scale apps.  Instead of using the file system, it's better to use an external service which is independent of the web tier.

While at JavaZone I sat down with <a href="https://twitter.com/peterhilton">Peter Hilton</a> and <a href="https://twitter.com/nicolasleroux">Nicolas Leroux</a> to come up with a way to handle this.  It only took us 30 minutes to get something working - start to finish - including setup time.  This is what is so compelling about Play Framework.  I've built many Java web apps and it always seems like I spend too much time setting up builds, IDEs, and plumbing.  With Play we were setup and working on the actual app in less than a minute.  After getting everything working locally it took another minute to actually run it on the cloud with Heroku.  The combination of Play Framework and Heroku is a developer's dream for fast-paced development and deployment.

All of the code for the sample application is on github:
<a href="https://github.com/jamesward/plays3upload">https://github.com/jamesward/plays3upload</a>

The basics of what we did was this:
<pre lang="java">
public static void doUpload(String comment, File attachment)
{
    AWSCredentials awsCredentials = new BasicAWSCredentials(System.getenv("AWS_ACCESS_KEY"), System.getenv("AWS_SECRET_KEY"));
    AmazonS3 s3Client = new AmazonS3Client(awsCredentials);
    s3Client.createBucket(BUCKET_NAME);
    String s3Key = UUID.randomUUID().toString();
    s3Client.putObject(BUCKET_NAME, s3Key, attachment);
    Document doc = new Document(comment, s3Key, attachment.getName());
    doc.save();
    listUploads();
}
</pre>

This uses a JPA Entity to persist the metadata about the file upload (for some reason we named it 'Document') and a reference to the file's key in S3.  But there was a sexier way, so my co-worker <a href="https://github.com/tkral">Tim Kral</a> added a new <a href="https://github.com/jamesward/plays3upload/blob/master/app/s3/storage/S3Blob.java">S3Blob</a> type that could be used directly in the JPA Entity.  Tim also cleaned up the configuration to make it more Play Framework friendly.  So lets walk through the entire app so you can see the pieces.

The <a href="https://github.com/jamesward/plays3upload/blob/master/app/models/Document.java">app/models/Document.java</a> JPA Entity has three fields - the file being of type S3Blob:
<pre lang="java">
package models;

import javax.persistence.Entity;

import play.db.jpa.Model;
import s3.storage.S3Blob;

@Entity
public class Document extends Model
{
    public String fileName;
    public S3Blob file;
    public String comment;
}
</pre>

The S3Blob is now doing all of the work to talk to the Amazon S3 APIs to persist and fetch the actual file.

Configuration of S3 is done by adding a plugin to the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/play.plugins">conf/play.plugins</a> file:
<pre lang="props">
0: s3.storage.S3Plugin
</pre>

The <a href="https://github.com/jamesward/plays3upload/blob/master/app/s3/storage/S3Blob.java">S3Plugin</a> handles reading the AWS credentials from the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/application.conf">conf/application.conf</a> file, setting up the S3Client, and creating the S3 Bucket - if necessary.

In the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/application.conf">conf/application.conf</a> file, environment variables are mapped to the configuration parameters in the Play application:
<pre lang="props">
aws.access.key=${AWS_ACCESS_KEY}
aws.secret.key=${AWS_SECRET_KEY}
s3.bucket=${S3_BUCKET}
</pre>

The values could be entered into the conf file directly but I used environment variables so they would be easier to change when running on Heroku.

The Amazon AWS API must be added to the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/dependencies.yml">conf/dependencies.yml</a> file:
<pre lang="yml">
require:
    - play
    - com.amazonaws -> aws-java-sdk 1.2.7
</pre>

The sample application has a new controller in <a href="https://github.com/jamesward/plays3upload/blob/master/app/controllers/Files.java">app/controllers/Files.java</a> that can display the upload form, handle the file upload, display the list of uploads, and handle the file download:
<pre lang="java">
package controllers;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.List;

import models.Document;
import play.libs.MimeTypes;
import play.mvc.Controller;
import s3.storage.S3Blob;

public class Files extends Controller
{

  public static void uploadForm()
  {
    render();
  }

  public static void doUpload(File file, String comment) throws FileNotFoundException
  {
    final Document doc = new Document();
    doc.fileName = file.getName();
    doc.comment = comment;
    doc.file = new S3Blob();
    doc.file.set(new FileInputStream(file), MimeTypes.getContentType(file.getName()));
    
    doc.save();
    listUploads();
  }

  public static void listUploads()
  {
    List<Document> docs = Document.findAll();
    render(docs);
  }

  public static void downloadFile(long id)
  {
    final Document doc = Document.findById(id);
    notFoundIfNull(doc);
    response.setContentTypeIfNotSet(doc.file.type());
    renderBinary(doc.file.get(), doc.fileName);
  }

}
</pre>

The <strong>uploadForm()</strong> method just causes the <a href="https://github.com/jamesward/plays3upload/blob/master/app/views/Files/uploadForm.html">app/views/Files/uploadForm.html</a> page to be displayed.

The <strong>doUpload()</strong> method handles the file upload and creates a new <strong>Document</strong> object that stores the file in S3 and the comment in a database.  After storing the file and comment it runs the <strong>listUploads()</strong> method. Of-course a database must be configured in the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/application.conf">conf/application.conf</a> file.  For running on Heroku the database is provided and just needs to be configured with the following values:
<pre lang="props">
db=${DATABASE_URL}
jpa.dialect=org.hibernate.dialect.PostgreSQLDialect
jpa.ddl=update
</pre>

The <strong>listUploads()</strong> method fetches all <strong>Document</strong> objects out of the database and then displays the <a href="https://github.com/jamesward/plays3upload/blob/master/app/views/Files/listUploads.html">apps/views/files/listUploads.html</a> page.

If a user selects a file from the list then the <strong>downloadFile()</strong> method is called which finds the file in S3 and sends it back to the client as a binary stream.  An alternative to this would be to get the file directly from Amazon using either the <a href="file:///home/jamesw/aws-java-sdk-1.2.6/documentation/javadoc/com/amazonaws/services/s3/AmazonS3Client.html#generatePresignedUrl(java.lang.String, java.lang.String, java.util.Date)">S3 generatePresignedUrl()</a> method or via <a href="http://aws.amazon.com/cloudfront/">CloudFront</a>.

Finally in the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/routes">conf/routes</a> file, requests to "/" have been mapped to the <strong>Files.uploadForm()</strong> method:
<pre lang="props">
GET     /                                       Files.uploadForm
</pre>

That's it!  Now we have an easy way to persist file uploads in an external system!

<h2>Running the Play! app on Heroku</h2>

If you'd like to run this example on Heroku, here is what you need to do:

Install the heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>.</li>

Login to Heroku via the command line:
<pre lang="bash">
heroku auth:login
</pre>

Clone the git repo:
<pre lang="bash">
git clone git@github.com:jamesward/plays3upload.git
</pre>

Move to the project dir:
<pre lang="bash">
cd plays3upload
</pre>

Create the app on Heroku:
<pre lang="bash">
heroku create -s cedar
</pre>

Set the AWS environment vars on Heroku:
<pre lang="bash">
heroku config:add AWS_ACCESS_KEY="YOUR_AWS_ACCESS_KEY" AWS_SECRET_KEY="YOUR_AWS_SECRET_KEY" S3_BUCKET="AN_AWS_UNIQUE_BUCKET_ID"
</pre>

Upload the app to Heroku:
<pre lang="bash">
git push heroku master
</pre>

Open the app in the browser:
<pre lang="bash">
heroku open
</pre>

Let me know if you have any questions or problems.  And thanks to Peter, Nicolas, and Tim for helping with this!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java and Play Framework on the Cloud at JavaZone]]></title>
    <link href="/source/2011/08/31/java-and-play-framework-on-the-cloud-at-javazone.html"/>
    <updated>2011-08-31T00:00:00-06:00</updated>
    <id>/source/2011/08/31/java-and-play-framework-on-the-cloud-at-javazone</id>
    <content type="html"><![CDATA[Next week I am speaking in Oslo at <a href="http://jz11.java.no/">JavaZone</a> about deploying Java and <a href="http://www.playframework.org">Play! Framework</a> apps on the Cloud.  I submitted the session before <a href="http://www.jamesward.com/2011/08/25/heroku-adds-java-support">Heroku for Java</a> was available so I had to obfuscate the title and description.  If you are at JavaZone then I hope to see you at my "<a href="http://javazone.no/incogito10/events/JavaZone%202011/sessions#f4ae4b01-1d5b-43fc-b635-af26388ddbf3">Deploying Apps on Heroku</a>" session!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started with Play Framework on Heroku]]></title>
    <link href="/source/2011/08/29/getting-started-with-play-framework-on-heroku.html"/>
    <updated>2011-08-29T00:00:00-06:00</updated>
    <id>/source/2011/08/29/getting-started-with-play-framework-on-heroku</id>
    <content type="html"><![CDATA[Last week Heroku announced that <a href="http://www.jamesward.com/2011/08/25/heroku-adds-java-support" title="Heroku Adds Java Support">you can now run Java apps on Heroku</a>.  Today <a href="http://blog.heroku.com/archives/2011/8/29/play/">Heroku announced</a> that you can also easily run <a href="http://www.playframework.org">Play Framework</a> apps on Heroku!  Here's a quick guide to getting started with Play! on Heroku:
<ol>
<li>Install the heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>.</li>
<li>Install <a href="http://git-scm.com/">git</a> and setup your SSH key</li>
<li><a href="http://www.playframework.org/download">Install Play! version 1.2.3</a></li>
<li>
Login to Heroku from the command line:
<pre lang="bash">heroku auth:login</pre>
</li>
<li>Create a new Play! app:
<pre lang="bash">play new play_hello_world
cd play_hello_world</pre>
</li>
<li>Run the app locally to test it:
<pre lang="bash">play run --%production</pre>
</li>
<li>Create a git repo, add the files, and commit:
<pre lang="bash">
git init
git add app conf lib public test
git commit -m init
</pre>
</li>
<li>Create a new app on Heroku:
<pre lang="bash">heroku create -s cedar</pre>
</li>
<li>Push the app to Heroku:
<pre lang="bash">git push heroku master</pre>
</li>
<li>Open the app in your browser:
<pre lang="bash">heroku open</pre>
</li>
</ol>

That's it!  If you want to learn more about Heroku, check out the <a href="https://github.com/heroku/java-workbook">Heroku for Java Workbook</a> and the <a href="http://devcenter.heroku.com/">Heroku Dev Center</a>.  And if you are at Dreamforce 2011 then check out <a href="http://geeks.aretotally.in/">Felipe Oliveira's</a> session on "Introducing Play! Framework: Painless Java and Scala Web Applications" on Wednesday at 3:30pm.

Let me know what you think and if you have any questions.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heroku Adds Java Support]]></title>
    <link href="/source/2011/08/25/heroku-adds-java-support.html"/>
    <updated>2011-08-25T00:00:00-06:00</updated>
    <id>/source/2011/08/25/heroku-adds-java-support</id>
    <content type="html"><![CDATA[Today <a href="http://blog.heroku.com/archives/2011/8/25/java/">Heroku announced</a> that Java is now supported on the Heroku Cloud Application Platform!  This is incredibly exciting news and I'm very lucky to be a Heroku for Java Developer Evangelist!

Joining salesforce.com and jumping into the the Java Cloud space holds some nostalgia for me.  When I began using Java in 1997 I was working at an ISP in Denver.  We did the regular web hosting thing, but when the first Java Servlet engines (like Java Web Server 1.0) came out, I created the "wantjava.com" hosting service.  Things were really nasty at first.  We could only run one instance of the JWS on a server so I came up with a really bad way to do "multi-tenancy".  I setup a cron job to rsync the customers' .class files into the server's webapp and then restart the server.  Customers had to email me to get a servlet added to the web.xml file.  Uggg...  I feel like I need to go to confession for this.  But it worked and as the Servlet containers improved we quickly migrated to a more sustainable model.

Now thirteen years later I am privileged to once again be part of Java on the Cloud.  But this time around things are so much easier, better, and sexier!  Heroku is a leading the way in a new generation of application deployment that is making things much better for us Java developers.

<h2>What is Heroku?</h2>

Shortly I will dive into how you can run Java on Heroku, but first, what is Heroku?  From my perspective, Heroku is a <a href="http://blog.heroku.com/archives/2011/8/3/polyglot_platform/">Polyglot Cloud Application Platform</a>.  Heroku provides us a way to run Ruby, Node.js, Clojure, and Java applications on a managed, scalable, and multi-tenant system.  Heroku also provides <a href="http://addons.heroku.com">numerous add-ons</a> that help us make the <a href="http://www.jamesward.com/2011/07/12/architectural-evolution-from-middleware-to-the-cloud">shift from monolithic middleware to Cloud Components</a>.  Another way to say it is:

<strong><pre>Heroku = Polyglot + Platform as a Service (PaaS) + Cloud Components</pre></strong>

It is very exciting to see these three things coming together!  With Polyglot I can choose the right tool for the job.  With PaaS I don't have to think about managing operating systems, scalability, failover, etc.  And with the Cloud Component Architecture I can keep my app thin and focused on what is unique to the problem it needs to solve.  Heroku brings these models together as a cloud application platform.

<h2>Running Java Apps on Heroku</h2>

Heroku can run any Java app that runs in OpenJDK 6.  Today Heroku uses Maven to create a "<a href="http://devcenter.heroku.com/articles/slug-compiler">slug</a>" for Java apps.  That slug can then be loaded onto one or more "<a href="http://devcenter.heroku.com/articles/dynos">dynos</a>".  You can tell a dyno to execute / start a Java app from the command line and you can also use a "<a href="http://devcenter.heroku.com/articles/procfile">Procfile</a>" to provide a command that will auto-start for each instance of a specific dyno type.  Web dynos are able to listen on a port and will receive HTTP traffic through a load balancer that is automatically setup for each app.  With that background knowledge, lets dive into code!

For Dreamforce 2011, I (with the help of a few co-workers) put together a <a href="http://github.com/heroku/java-workbook">Heroku for Java Workbook</a>.  The Workbook provides detailed instructions on how to create web apps, connect to a database, setup worker processes, use the Redis to Go Heroku add-on, and use Spring Roo on Heroku.  But if you are anxious to get started and don't need as much hand-holding, here is a quick and very simple walk through of how to run Java on Heroku:

<ol>
<li>Install the heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>.</li>
<li>Install <a href="http://git-scm.com/">git</a> and setup your ssh key</li>
<li>Install <a href="http://maven.apache.org">Maven</a></li>
<li>
Login to Heroku from the command line:
<pre lang="bash">heroku auth:login</pre>
</li>
<li>
Create a new project directory and move into it:
<pre lang="bash">mkdir helloherokujava
cd helloherokujava</pre>
</li>
<li>
Create a Maven build file named <code>pom.xml</code> containing:
<pre lang="xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>foo</groupId>
    <version>1.0-SNAPSHOT</version>
    <name>helloherokujava</name>
    <artifactId>helloherokujava</artifactId>
</project>
</pre>
</li>
<li>
Create a Java source directory:
<pre lang="bash">mkdir -p src/main/java</pre>
</li>
<li>
Create a new Java class in the <code>src/main/java</code> directory named <code>Hello.java</code> containing:
<pre lang="java">public class Hello
{
  public static void main(String[] args)
  {
    System.out.println("hello, world");
  }
}</pre>
</li>
<li>
Compile the class:
<pre lang="bash">mvn compile</pre>
</li>
<li>
Run the class locally:
<pre lang="bash">java -cp target/classes Hello</pre>
</li>
<li>
Create a local git repo, add the <code>pom.xml</code> file & <code>src</code> dir, and commit the files:
<pre lang="bash">git init
git add pom.xml src
git commit -m init</pre>
</li>
<li>
Create a new app on Heroku using the Cedar stack:
<pre lang="bash">heroku create -s cedar</pre>
</li>
<li>
Upload your app to Heroku:
<pre lang="bash">git push heroku master</pre>
Heroku will create a slug for your app.
</li>
<li>
Run the app on Heroku:
<pre lang="bash">heroku run "java -cp target/classes Hello"</pre>
Heroku will start a new dyno with your slug and then run the specified command.
</li>
</ol>
You just ran Java on the cloud!  Obviously this is a very simple example.  But I like to start new things with the simplest thing that could possibly work.  Now that you have that working there is more to learn and much more power to harness!

<h2>Next Steps</h2>

<ul>
<li>Go through the <a href="http://github.com/heroku/java-workbook">Heroku for Java Workbook</a>
</li>
<li>Go through the articles on the <a href="http://devcenter.heroku.com/articles/java">Heroku Dev Center</a>
</li>
<li>Ask questions about Heroku on <a href="http://stackoverflow.com">StackOverflow</a>
</li>
<li>Keep watching here for many more blogs about Java on Heroku</li>
</ul>

Have fun and please let me know if you have any questions about Heroku.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WAR-less Java Web Apps]]></title>
    <link href="/source/2011/08/23/war-less-java-web-apps.html"/>
    <updated>2011-08-23T00:00:00-06:00</updated>
    <id>/source/2011/08/23/war-less-java-web-apps</id>
    <content type="html"><![CDATA[Have you ever thought about why in Java we package up web apps into WAR files (or WAR directory structures)? It certainly is a convenient way to move an application and its dependencies from one place to another. But wouldn't it be nice if everything could just stay in its original location and there wouldn't be any moving of files around? Wouldn't it also be nice if you specified your required version of Jetty or Tomcat just like you do with every other dependency? The WAR-less approach is one that is catching on as emerging Java web frameworks like <a href="http://www.playframework.org/">Play!</a> ditch the WAR files. With standard Java web apps we can also ditch the WAR files by simply launching an embedded Jetty or Tomcat server. Let's give this a try and see how it goes.

For this experiment I'm going to use Maven and Jetty. This will still use the same standard source structure for a WAR file (<em>src/main/java</em>, <em>src/main/webapp</em>, etc). The major difference is that I will actually startup Jetty using a good-old <em>static void main</em>. This is similar to using the <em>jetty:run</em> goal but will allow us to have the same exact setup in development and in production. The static stuff will be in <em>src/main/webapp</em>, the compiled classes will be in target/classes, and the dependencies will be right were Maven downloaded them to. First, here is a little Java class (<em>src/main/java/foo/Main.java</em>) that sets up a Jetty server and starts it:
<pre lang="java">
package foo;

import java.io.File;
import java.net.URL;
import java.util.jar.Attributes;
import java.util.jar.JarFile;

import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.handler.*;
import org.eclipse.jetty.util.StringUtil;
import org.eclipse.jetty.webapp.WebAppContext;

public class Main
{

  public static void main(String[] args) throws Exception
  {
    String webappDirLocation = "src/main/webapp/";

    Server server = new Server(8080);
    WebAppContext root = new WebAppContext();

    root.setContextPath("/");
    root.setDescriptor(webappDirLocation + "/WEB-INF/web.xml");
    root.setResourceBase(webappDirLocation);

    root.setParentLoaderPriority(true);

    server.setHandler(root);

    server.start();
    server.join();
  }
}
</pre>

As you can see, Main just references the webapp directory so I don't have to copy the stuff from there to another place. Next I have a little test servlet (<em>src/main/java/foo/HelloServlet.java</em>):
<pre lang="java">
package foo;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class HelloServlet extends HttpServlet
{   

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
  {
    PrintWriter out = resp.getWriter();
    out.println("hello, world");
    out.close();
  }
}
</pre>

And now the <em>web.xml</em> file (<em>src/main/webapp/WEB-INF/web.xml</em>):
<pre lang="xml">
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
  version="2.5">
  <servlet>
    <servlet-name>HelloServlet</servlet-name>
    <servlet-class>foo.HelloServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>HelloServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
</pre>

And finally a <em>pom.xml</em> file that specifies Jetty as a dependency and provides an easy way to run the Main class:
<pre lang="xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>com.jamesward</groupId>
  <version>1.0-SNAPSHOT</version>
  <name>warless_java_web_app</name>
  <artifactId>warless_java_web_app</artifactId>
  <packaging>jar</packaging>

  <properties>
    <jettyVersion>7.3.1.v20110307</jettyVersion>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.eclipse.jetty</groupId>
      <artifactId>jetty-server</artifactId>
      <version>${jettyVersion}</version>
    </dependency>
    <dependency>
      <groupId>org.eclipse.jetty</groupId>
      <artifactId>jetty-webapp</artifactId>
      <version>${jettyVersion}</version>
    </dependency>
    <dependency>
      <groupId>org.eclipse.jetty</groupId>
      <artifactId>jetty-servlet</artifactId>
      <version>${jettyVersion}</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>1.2</version>
        <configuration>
          <mainClass>foo.Main</mainClass>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
</pre>

And now simply run:
<pre lang="bash">
mvn compile exec:java
</pre>

Maven compiles my Java classes into <em>target/classes</em> and then the <em>exec:java</em> goal runs the Main which finds the other WAR assets in the <em>src/main/webapp</em> directory. If you have been following along, make a request to <a href="http://localhost:8080/">http://localhost:8080/</a> to verify that it works (which it should).

There are two alternatives to running Jetty from Maven. You can use the Maven appassembler plugin to create start scripts containing the correct <em>CLASSPATH</em> references and then launch Main class using the generated scripts. Or you can use the Maven assembly or shade plugin to create a JAR containing the application and all of its dependencies.

Here is an example section of a <em>pom.xml</em> file for using the appassembler plugin:
<pre lang="xml">
  <plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>appassembler-maven-plugin</artifactId>
    <version>1.1.1</version>
    <configuration>
      <assembleDirectory>target</assembleDirectory> 
      <generateRepository>false</generateRepository>
      <programs>
        <program>
          <mainClass>foo.Main</mainClass>
          <name>main</name>
        </program>
      </programs>
    </configuration>
    <executions>
      <execution>
        <phase>package</phase>
        <goals>
          <goal>assemble</goal>
        </goals>
      </execution>          
    </executions>
  </plugin>
</pre>

To generate the start scripts simply run:
<pre lang="bash">
mvn install
</pre>

Then to run the script set the REPO environment variable to your Maven repository:
<pre lang="bash">
export REPO=~/.m2/repository
</pre>

And then simply run the script:
<pre lang="bash">
sh target/bin/main
</pre>

All of the code for this example is on github.com:
<a href="https://github.com/jamesward/warless_java_web_apps">https://github.com/jamesward/warless_java_web_apps</a>

To make all of this even easier, Jetty has a Maven archetype for generating everything for you. To create a new project containing this setup run:
<pre lang="bash">
mvn archetype:generate -DarchetypeGroupId=org.mortbay.jetty.archetype -DarchetypeArtifactId=jetty-archetype-assembler -DarchetypeVersion=7.5.0-SNAPSHOT
</pre>

And now you are ready to build a WAR-less Java web app!

This setup is really the bare minimum required to handle web resource and servlet requests you will need to do a little more work if you want to add JSP support. Find out more about this in the <a href="http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty#Embedding_JSP">Jetty documentation</a>.

So... What do you think about Java Web apps without WAR files & WAR packaging? I'd love to hear your thoughts!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dreamforce 2011]]></title>
    <link href="/source/2011/08/10/dreamforce-2011.html"/>
    <updated>2011-08-10T00:00:00-06:00</updated>
    <id>/source/2011/08/10/dreamforce-2011</id>
    <content type="html"><![CDATA[I'm very excited to be presenting at <a href="http://www.salesforce.com/dreamforce/DF11/">Dreamforce</a> (salesforce.com's anual conference) this year!  On Thursday, September 1, from 1:15 pm to 2:15 pm I will be presenting:
<blockquote><strong>Developing Java Cloud Apps</strong>
The cloud makes it easy to deploy highly scalable apps in an instant. This session will walk you through the steps to build your first Java app for the cloud. You'll also learn best practices for building mission-critical and horizontally scalable Java cloud apps.</blockquote>

Then on Friday, September 2, from 10:00 am to 11:00 am I will be hosting a panel discussion:
<blockquote><strong>Fireside Chat: Java on the Cloud</strong>
Come join the Java on the cloud product managers, architects, and experts for a casual, unscripted chat to find out how Java developers can best take advantage of the cloud. The session will be a mix of preselected and audience-provided questions. So bring all your tough, interesting, and quirky questions to this Fireside Chat.</blockquote>

I hope to see you there!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Play Framework with Scala in IntelliJ]]></title>
    <link href="/source/2011/07/28/setup-play-framework-with-scala-in-intellij.html"/>
    <updated>2011-07-28T00:00:00-06:00</updated>
    <id>/source/2011/07/28/setup-play-framework-with-scala-in-intellij</id>
    <content type="html"><![CDATA[Yesterday at the <a href="https://sites.google.com/site/programmingsummercamp/">Programming Summer Camp</a> a group of us were working together to learn the <a href="http://www.playframework.org/">Play Framework</a>.  Once we were able to get the basics working we wanted to get everything working in <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>.  Due to a lack of good documentation on the subject things did not go smoothly until we figured out the right "magical incantations".  We did eventually get it working so I wanted to document the steps we took.

<ol>
<li>Add Scala support to Play:
<pre lang="bash">
play install scala
</pre></li>
<li>Create a new Play project with Scala support:
<pre lang="bash">
play new foo --with scala
</pre></li>
<li>Have Play create an IntelliJ Module Descriptor:
<pre lang="bash">
play idealize foo
</pre></li>
<li>Run the app:
<pre lang="bash">
play run foo
</pre></li>
<li>Access the app in a browser to generate some source files we will use later:
<a href="http://localhost:9000">http://localhost:9000</a></li>
<li>Shutdown the Play server.</li>
<li>Currently the Play Scala Module (version 0.9.1) only supports Scala 2.8.1 so <a href="http://www.scala-lang.org/node/165">download</a> and extract that version.</li>
<li>Create a new project (from scratch) in IntelliJ.  The location should be the same as the directory where the Play project was created.  Un-check the "Create module" option.<img src="http://www.jamesward.com/wp/uploads/2011/07/1.png" alt="" title="New Project" width="705" height="534" class="alignnone size-full wp-image-2495" /></li>
<li>In the Project Structure window, with "Modules" selected, click the "+" button to add a new module to the project.</li>
<li>Select the "Import existing module" option and then point it to the generated .iml file.<img src="http://www.jamesward.com/wp/uploads/2011/07/2.png" alt="" title="Add Module" width="612" height="500" class="alignnone size-full wp-image-2496" /></li>
<li>With the module now selected, select the content root block for the module (mine is /home/jamesw/projects/foo).  Then select the "tmp/generated" directory in the tree on the right and press the "Sources" button.  The HTML template pages are converted to .scala source files by Play and we need these source files to be included in the project along with the regular source files in the app directory.<img src="http://www.jamesward.com/wp/uploads/2011/07/3.png" alt="" title="Content Root" width="801" height="644" class="alignnone size-full wp-image-2497" /></li>
<li>Select "Global Libraries" in the Platform Settings on the left and add a new Java Library named "scala-compiler-2.8.1".  Then press the "Attach Classes..." button and navigate to the "lib" directory in your Scala 2.8.1 directory.  Then select the "scala-compiler.jar" and "scala-library.jar" files.</li>
<li>Add another Global Library named "scala-library-2.8.1" containing the "scala-dbc.jar", "scala-library.jar", and "scala-swing.jar" files.<img src="http://www.jamesward.com/wp/uploads/2011/07/6.png" alt="" title="Global Libraries" width="997" height="654" class="alignnone size-full wp-image-2498" /></li>
<li>Press the "Apply" button to save the Global Libraries configuration.</li>
<li>Select "Modules" and then the "Dependencies" tab.  Press the "Add..." button and select "Library" to add a new library to the module.  Select "scala-library-2.8.1" and then press the "Add Selected" button to add it to the Dependencies.<img src="http://www.jamesward.com/wp/uploads/2011/07/7.png" alt="" title="Dependencies" width="1071" height="654" class="alignnone size-full wp-image-2499" /></li>
<li>Select the "Scala" Facet in the module and set the Compiler library to the "scala-compiler-2.8.1" option.<img src="http://www.jamesward.com/wp/uploads/2011/07/8.png" alt="" title="Scala Facet" width="933" height="653" class="alignnone size-full wp-image-2500" /></li>
<li>Save the Project Structure by pressing the "Ok" button.  Make sure the project now builds without any errors.</li>
<li>To run the Play server from IntelliJ a new Run Configuration must be configured.  To create a new Run Configuration select "Run" from the main IntelliJ menu and then select "Edit Configurations".</li>
<li>Press the "+" button and select "Application" from the list of Run Configuration types.</li>
<li>Set the name to "Play Server".</li>
<li>Set the Main class to "play.server.Server".</li>
<li>Set the VM Parameters to:
<pre lang="bash">
-Dapplication.path="."
</pre></li>
<li>De-select the "Make" option in the "Before Launch" section.</li>
<li>Press the "Ok" button to save the configuration. <img src="http://www.jamesward.com/wp/uploads/2011/07/9.png" alt="" title="Run Configuration" width="697" height="650" class="alignnone size-full wp-image-2501" /></li>
<li>Run the Play Server by selecting "Run" from the "Run" IntelliJ menu and verify that the application still works by opening the application in a browser.</li>
</ol>

It is so much easier to figure this stuff out with a group of people.  That is just one of the many reasons why the Programming Summer Camp is a great event!

Let me know if you have any questions or problems.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architectural Evolution: From Middleware to The Cloud]]></title>
    <link href="/source/2011/07/12/architectural-evolution-from-middleware-to-the-cloud.html"/>
    <updated>2011-07-12T00:00:00-06:00</updated>
    <id>/source/2011/07/12/architectural-evolution-from-middleware-to-the-cloud</id>
    <content type="html"><![CDATA[You've heard it said that "all things old are new again."  That statement can certainly be applied to the current Cloud hype.  But each time the old becomes new it gets a bit better because of what was learned the last time around.  If we look back ten years at enterprise application development in Java things were quite different than they are today.  EJB was "the way" to build scalable systems from a vast abundance of components.  But things didn't work out as well as the vendors planned.

<strong>EJB Component Architecture</strong>

I remember back in the early days of enterprise Java everyone was talking about "Components."  Application complexity would be greatly reduced because there would be components for everything!  Need to connect your app to Exchange?  Well, there's a component for that.  Does your app need to send email?  No problem, there are twenty components for that!  Component marketplaces flourished with VC funding galore.

The official way to build reusable Java components became standardized as <em>Enterprise Java Beans</em> (EJB).  These "beans" could be accessed either locally or remotely!  Vendors led us to believe this was the panacea of Lego-style application development.  Just grab pieces from every-which place and hook them together.  Hooking the components together required a heavyweight "Middleware" server.  Here is what Monolithic Middleware with EJBs looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_j2ee.png" alt="" title="J2EE Architecture" width="526" height="314" class="alignnone size-full wp-image-2456" />

But the EJB Component Architecture didn't work.  Billions of dollars were spent on components and the middleware to tie them all together.  And now I bet you can't find a single person that doesn't regret going that route.  Why?  Three primary reasons...

<ol>
<li>The programming model was too hard.  The EJB programming model consisted of too much boilerplate code ("solved" through code-gen tools like xdoclet).  EJB's also required configuration which was often middleware server-specific.  The EJB Component Architecture creates too many layers of indirection (<a href="http://java.sun.com/blueprints/corej2eepatterns/">Core J2EE Patterns</a> anyone?).</li>
<li>Scalability was too hard.  EJBs can either run inside your container (using what is called a "Local Interface") or somewhere else (a "Remote Interface").  Using Local Interfaces is fast but causes middleware to run into memory limits and scaling bloated app servers is challenging.  Using Remote Interfaces leads to massive serialization and routing overhead and whatever is on the remote end of the wire is still a pain to scale.</li>
<li>Deployment was too hard.  Remember the days when starting up an app server / middleware container took minutes not seconds?</li>
</ol>

If you need further proof that the middleware model didn't work then just try to name one place you can still go to buy an EJB component today.  Obviously we needed another way to compose the parts of an application.

<strong>POJO Component Architecture</strong>

SpringSource deserves a lot of credit for pulling us out of the EJB muck.  They created a model where the application pieces are <em>Plain Old Java Objects</em> (POJOs) injected into an application.  This led to better testability, much easier deployment, and a much better programming model.  Essentially the revolution of Spring was to make all those app pieces injectable dependencies.  This was a huge step forward.  But there are still some limitations with this model that are currently being addressed by the next revolution.  The three primary challenges with the POJO Component Architecture are:

<ol>
<li>Isolation is too hard.  It is now very easy to throw a bunch of components together into a single Web application ARchive (WAR).  But at some point all of these pieces being stacked on top of each other make our application brittle and difficult to piece together.  What do you do when the version of Hibernate you want to use requires a different version of an Apache Commons library than the version of XFire that you want to use?  Or when two libraries that your app needs actually require conflicting dependencies.  Sometimes isolating the pieces of an application is actually simpler than injecting them.  And unfortunately with POJOs you may not be able to easily switch from using a "Local Interface" to an external "Remote Interface" like you can with EJBs.</li>
<li>Polyglot is too hard.  The POJO components we use today in our systems are not inherently supportive of a Polyglot world where different parts of a system may be built using different technologies.  Suppose your system has a rules engine and you want to access it from a Java-based application and a Ruby-based application.  Today the only way to do that is to proxy that component and expose it through an easily serialization protocol (likely XML or JSON over HTTP).  This will likely add unnecessary complexity to your system.  When the high-level functional pieces of a system are technology-specific the entire system may be forced to use that technology or those pieces may exist multiple times to support the Polyglot nature of today's systems.</li>
<li>Scaling is still too hard.  As we continue to stack more pieces on top of each other it becomes harder to stick with simple, lightweight share-nothing architectures where each piece is individually horizontally scalable.</li>
</ol>

<strong>Cloud Component Architecture</strong>

The emerging solution to the challenges we have faced with the EJB and POJO Component Architectures is the Cloud Component Architecture.  Instead of bundling components for things like search indexing, distributed caching, SMTP, and NoSQL data storage into your application those high level functions can instead be used as Cloud Components.  There are already numerous vendors providing "Component as a Service" products like MongoDB, Redis, CouchDB, Lucene Search, SMTP, and Memcache.

SMTP / outbound email is a simple example where the Cloud Component Architecture makes a lot of sense.  With the EJB and POJO Component Architectures I'd find a SMTP component that simply sends email.  Then configure my server to be able to send emails that aren't considered spam.  I'd also need to deal with constant blacklisting challenges and a larger management surface.  Or in a Cloud Component Architecture I could simply sign-up with one of the SMTP as a Service providers like <a href="http://www.authsmtp.com/">AuthSMTP</a> or <a href="http://sendgrid.com/">SendGrid</a> and then just use the Component as a Service.

Here is what the new Cloud Component Architecture for application composition looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_csa.png" alt="" title="Cloud Component Architecture" width="512" height="369" class="alignnone size-full wp-image-2457" />

The top six benefits of the Cloud Component Architecture are:

<ol>
<li>Simple scalability.  By making each functional piece of an application an independent and lightweight service they can each be horizontally scaled without impacting the overall application architecture or configuration.  If you chose to use a vendor's Component as a Service then they will handle the scalability of those pieces.  Then you only need to scale a very thin web layer.  Composing Cloud Components also makes it easier to stick with a share-nothing architecture that is much easier to scale than the traditional architectures.</li>
<li>Rapid composition.  Cloud Components are flourishing!  Most of the basic building blocks that applications need are now provided "as a Service" by vendors who maintain and enhance them.  This is a much more erosion-resistant way to assemble applications when compared to the typical abandon-ware which is prevalent with many Java components.  Many of the emerging Cloud Components also provide client libraries for multiple platforms and RESTful APIs to support easy composition in Polyglot systems.</li>
<li>Reduced management surface.  With Cloud Components you can reduce the number of pieces you must manage down to only the stuff that is unique to your app.  Each Cloud Component you add doesn't enlarge the management surface like it does in typical component models where you own the implementation of the component.</li>
<li>Simple Deployment.  One of the biggest benefits of using the Cloud is the ease of deployment.  Partitioning the functional pieces of an application makes it thinner and easier to deploy.  With Cloud Components you can also setup development and staging instances that make it easy to simulate the production environment.  Then moving from one environment to another is simply a matter of configuration.</li>
<li>Better Security.  In most application architectures today there is one layer of security.  This would be like a bank without a vault.  There are a few ways into the bank that are wrapped with security (doors with locks) but as soon as someone has found a way in, they have access to everything.  With Cloud Components security can be more easily distributed to provide multiple layers of security.</li>
<li>Manageable costs.  With Cloud Components your costs can scale with your usage.  This means it's easy to get started and grow rather than make large up-front investments.</li>
</ol>

The Cloud Component Architecture may seem similar in ways to the old EJB and POJO Component Architectures because it is similar!  The wheel has not been reinvented, just improved.  The dream of Lego-style application assembly is now being realized because we've come full circle on some old ideas from twenty years ago (<a href="http://en.wikipedia.org/wiki/Corba">CORBA</a> anyone?).  This time around those ideas are reality thanks to the evolution of many independent pieces like REST, Polyglot, and the Share-Nothing pattern.  Cloud Components are the foundation of a new era of application development.  My only question is...  How long before we see the <a href="http://en.wikipedia.org/wiki/UDDI">UDDI</a> idea again?  ;)
]]></content>
  </entry>
  
</feed>
