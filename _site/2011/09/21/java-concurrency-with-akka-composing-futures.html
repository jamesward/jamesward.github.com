I've been intrigued by <a href="http://akka.io/">Akka</a> for a while but finally I was able to take it for a spin.  The first thing I wanted to learn was how to compose Futures.  Composing Futures provides a way to do two (or more) things at the same time and then wait until they are done.  Typically in Java this would be done with a <code><del datetime="2011-09-23T22:23:58+00:00">CyclicBarrier</del></code> <code>ExecutorService</code>.  <del datetime="2011-09-23T22:23:58+00:00">But setting up the code to manage a <code>CyclicBarrier</code> is challenging.</del>  <em>(UPDATE: Turns out it's not very challenging, I just didn't know how to do it.  I'm new to concurrency in Java and didn't find much on this stuff - probably because I didn't even know what to search for.)</em>  So I put together a quick little demo that shows how to do the same thing with Futures in Akka.

All of the code for this demo is on github:
<a href="http://github.com/jamesward/AkkaFun">http://github.com/jamesward/AkkaFun</a>

First I setup a Gradle build that pulls in the Akka dependency and will allow me to easily launch the demo app.  Here is the <code>build.gradle</code> file:

<pre lang="groovy">
apply plugin:"application"
mainClassName = "com.jamesward.akkafun.SimpleFutures"

repositories {
    mavenCentral()
}

dependencies {
  compile "se.scalablesolutions.akka:akka-actor:1.2-RC6"
}
</pre>

For this demo I also wanted to increase the Akka timeout to 1 minute (the default is 5 seconds).  To do this I created a <code>src/main/resources/akka.conf</code> file containing:
<pre lang="json">
akka {
    actor {
        timeout = 60
    }
}
</pre>

I then setup a <code>Callable</code> class that does some work and then returns it's result.  For this example the work is just to pause for a random amount of time and the result is the amount of time it paused for.  Here is the <code>src/main/java/com/jamesward/akkafun/RandomPause.java</code> file:
<pre lang="java">
package com.jamesward.akkafun;

import java.util.concurrent.Callable;

public class RandomPause implements Callable<Long>
{

    private Long millisPause;

    public RandomPause()
    {
        millisPause = Math.round(Math.random() * 8000) + 2000; // 2,000 to 10,000
        System.out.println(this.toString() + " will pause for " + millisPause + " milliseconds");
    }

    public Long call() throws Exception
    {
        Thread.sleep(millisPause);
        System.out.println(this.toString() + " was paused for " + millisPause + " milliseconds");
        return millisPause;
    }
}
</pre>

I used a simple Java app to compose the <code>RandomPause</code> futures.  Here is the <code>src/main/java/com/jamesward/akkafun/SimpleFutures.java</code> file:

<pre lang="java">
package com.jamesward.akkafun;

import java.util.ArrayList;
import java.util.List;

import akka.dispatch.Future;
import static akka.dispatch.Futures.future;
import static akka.dispatch.Futures.sequence;

public class SimpleFutures
{
    public static void main(String[] args)
    {
        List<Future<Long>> futures = new ArrayList<Future<Long>>();

        System.out.println("Adding futures for two random length pauses");

        futures.add(future(new RandomPause()));
        futures.add(future(new RandomPause()));

        System.out.println("There are " + futures.size() + " RandomPause's currently running");

        // compose a sequence of the futures
        Future<Iterable<Long>> futuresSequence = sequence(futures);

        // block until the futures come back
        Iterable<Long> results = futuresSequence.get();

        System.out.println("All RandomPause's are complete");

        Long totalPause = 0L;
        for (Long result : results)
        {
            System.out.println("One pause was for " + result + " milliseconds");
            totalPause += result;
        }

        System.out.println("Total pause was for " + totalPause + " milliseconds");
    }
}
</pre>

Lets walk through the pieces of this.

First, a place to store the list of Futures is created:
<pre lang="java">
List<Future<Long>> futures = new ArrayList<Future<Long>>();
</pre>

The <code>Future</code> object is parameterized with the type of result the <code>Future</code> will return - a <code>Long</code> in this case. (I'm using the Akka <code>Future</code> not the regular Java <code>Future</code>.)

The <code>Futures.future</code> static method is used to create a new <code>Future</code> from an instance of a <code>Callable</code> object and that Future is added to the list of Futures:

<pre lang="java">
futures.add(future(new RandomPause()));
</pre>

In this case a <code>RandomPause</code> instance is created.  This is done twice to add two futures to the list.

You may have noticed in <code>RandomPause</code> that <code>Callable</code> is parameratized with a <code>Long</code>:

<pre lang="java">
public class RandomPause implements Callable<Long>
</pre>

The result of the work (the <code>call</code> method) returns a <code>Long</code> so the <code>Callable</code> and the <code>Future</code> must be parameratized with a Long.

In order to compose the futures together, another <code>Future</code> will be created containing the sequence of the list of futures:

<pre lang="java">
Future<Iterable<Long>> futuresSequence = sequence(futures);
</pre>

The <code>Future</code> is parameratized with an <code>Iterable</code> which is parameratized with a Long to match the result of the <code>Callable</code>.  The <code>Futures.sequence</code> method is used to create the new <code>Future</code> from the list of Futures.

Using the <code>futuresSequence</code> the applicaiton can wait (or block) until the <code>RandomPause</code> objects in <code>futures</code> list have all returned, or the timeout was reached:

<pre lang="java">
Iterable<Long> results = futuresSequence.get();
</pre>

Each result is now available.  That seems too easy!  Thanks Akka!

Let me know if you have any questions about this example.
