
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Architectural Evolution: From Middleware to The Cloud - James Ward</title>
  <meta name="author" content="James Ward">

  
  <meta name="description" content="You&#8217;ve heard it said that &#8220;all things old are new again.&#8221; That statement can certainly be applied to the current Cloud hype. But &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jamesward.github.com/2011/07/12/architectural-evolution-from-middleware-to-the-cloud">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="James Ward" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-784803-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">James Ward</a></h1>
  
    <h2>Heroku | Java | Scala | Cloud | Open Source | Linux</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jamesward.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/about-james-ward">About James Ward</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Architectural Evolution: From Middleware to the Cloud</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-12T11:10:22-06:00" pubdate data-updated="true">Jul 12<span>th</span>, 2011</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>You&#8217;ve heard it said that &#8220;all things old are new again.&#8221;  That statement can certainly be applied to the current Cloud hype.  But each time the old becomes new it gets a bit better because of what was learned the last time around.  If we look back ten years at enterprise application development in Java things were quite different than they are today.  EJB was &#8220;the way&#8221; to build scalable systems from a vast abundance of components.  But things didn&#8217;t work out as well as the vendors planned.</p>

<p><strong>EJB Component Architecture</strong></p>

<p>I remember back in the early days of enterprise Java everyone was talking about &#8220;Components.&#8221;  Application complexity would be greatly reduced because there would be components for everything!  Need to connect your app to Exchange?  Well, there&#8217;s a component for that.  Does your app need to send email?  No problem, there are twenty components for that!  Component marketplaces flourished with VC funding galore.</p>

<p>The official way to build reusable Java components became standardized as <em>Enterprise Java Beans</em> (EJB).  These &#8220;beans&#8221; could be accessed either locally or remotely!  Vendors led us to believe this was the panacea of Lego-style application development.  Just grab pieces from every-which place and hook them together.  Hooking the components together required a heavyweight &#8220;Middleware&#8221; server.  Here is what Monolithic Middleware with EJBs looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_j2ee.png" alt="" /></p>

<p>But the EJB Component Architecture didn&#8217;t work.  Billions of dollars were spent on components and the middleware to tie them all together.  And now I bet you can&#8217;t find a single person that doesn&#8217;t regret going that route.  Why?  Three primary reasons&#8230;</p>

<ol>
<li><p>The programming model was too hard.  The EJB programming model consisted of too much boilerplate code (&#8220;solved&#8221; through code-gen tools like xdoclet).  EJB&#8217;s also required configuration which was often middleware server-specific.  The EJB Component Architecture creates too many layers of indirection (<a href="http://java.sun.com/blueprints/corej2eepatterns/">Core J2EE Patterns</a> anyone?).</p></li>
<li><p>Scalability was too hard.  EJBs can either run inside your container (using what is called a &#8220;Local Interface&#8221;) or somewhere else (a &#8220;Remote Interface&#8221;).  Using Local Interfaces is fast but causes middleware to run into memory limits and scaling bloated app servers is challenging.  Using Remote Interfaces leads to massive serialization and routing overhead and whatever is on the remote end of the wire is still a pain to scale.</p></li>
<li><p>Deployment was too hard.  Remember the days when starting up an app server / middleware container took minutes not seconds?</p></li>
</ol>


<p>If you need further proof that the middleware model didn&#8217;t work then just try to name one place you can still go to buy an EJB component today.  Obviously we needed another way to compose the parts of an application.</p>

<p><strong>POJO Component Architecture</strong></p>

<p>SpringSource deserves a lot of credit for pulling us out of the EJB muck.  They created a model where the application pieces are <em>Plain Old Java Objects</em> (POJOs) injected into an application.  This led to better testability, much easier deployment, and a much better programming model.  Essentially the revolution of Spring was to make all those app pieces injectable dependencies.  This was a huge step forward.  But there are still some limitations with this model that are currently being addressed by the next revolution.  The three primary challenges with the POJO Component Architecture are:</p>

<ol>
<li><p>Isolation is too hard.  It is now very easy to throw a bunch of components together into a single Web application ARchive (WAR).  But at some point all of these pieces being stacked on top of each other make our application brittle and difficult to piece together.  What do you do when the version of Hibernate you want to use requires a different version of an Apache Commons library than the version of XFire that you want to use?  Or when two libraries that your app needs actually require conflicting dependencies.  Sometimes isolating the pieces of an application is actually simpler than injecting them.  And unfortunately with POJOs you may not be able to easily switch from using a &#8220;Local Interface&#8221; to an external &#8220;Remote Interface&#8221; like you can with EJBs.</p></li>
<li><p>Polyglot is too hard.  The POJO components we use today in our systems are not inherently supportive of a Polyglot world where different parts of a system may be built using different technologies.  Suppose your system has a rules engine and you want to access it from a Java-based application and a Ruby-based application.  Today the only way to do that is to proxy that component and expose it through an easily serialization protocol (likely XML or JSON over HTTP).  This will likely add unnecessary complexity to your system.  When the high-level functional pieces of a system are technology-specific the entire system may be forced to use that technology or those pieces may exist multiple times to support the Polyglot nature of today&#8217;s systems.</p></li>
<li><p>Scaling is still too hard.  As we continue to stack more pieces on top of each other it becomes harder to stick with simple, lightweight share-nothing architectures where each piece is individually horizontally scalable.</p></li>
</ol>


<p><strong>Cloud Component Architecture</strong></p>

<p>The emerging solution to the challenges we have faced with the EJB and POJO Component Architectures is the Cloud Component Architecture.  Instead of bundling components for things like search indexing, distributed caching, SMTP, and NoSQL data storage into your application those high level functions can instead be used as Cloud Components.  There are already numerous vendors providing &#8220;Component as a Service&#8221; products like MongoDB, Redis, CouchDB, Lucene Search, SMTP, and Memcache.</p>

<p>SMTP / outbound email is a simple example where the Cloud Component Architecture makes a lot of sense.  With the EJB and POJO Component Architectures I&#8217;d find a SMTP component that simply sends email.  Then configure my server to be able to send emails that aren&#8217;t considered spam.  I&#8217;d also need to deal with constant blacklisting challenges and a larger management surface.  Or in a Cloud Component Architecture I could simply sign-up with one of the SMTP as a Service providers like <a href="http://www.authsmtp.com/">AuthSMTP</a> or <a href="http://sendgrid.com/">SendGrid</a> and then just use the Component as a Service.</p>

<p>Here is what the new Cloud Component Architecture for application composition looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_csa.png" alt="" /></p>

<p>The top six benefits of the Cloud Component Architecture are:</p>

<ol>
<li><p>Simple scalability.  By making each functional piece of an application an independent and lightweight service they can each be horizontally scaled without impacting the overall application architecture or configuration.  If you chose to use a vendor&#8217;s Component as a Service then they will handle the scalability of those pieces.  Then you only need to scale a very thin web layer.  Composing Cloud Components also makes it easier to stick with a share-nothing architecture that is much easier to scale than the traditional architectures.</p></li>
<li><p>Rapid composition.  Cloud Components are flourishing!  Most of the basic building blocks that applications need are now provided &#8220;as a Service&#8221; by vendors who maintain and enhance them.  This is a much more erosion-resistant way to assemble applications when compared to the typical abandon-ware which is prevalent with many Java components.  Many of the emerging Cloud Components also provide client libraries for multiple platforms and RESTful APIs to support easy composition in Polyglot systems.</p></li>
<li><p>Reduced management surface.  With Cloud Components you can reduce the number of pieces you must manage down to only the stuff that is unique to your app.  Each Cloud Component you add doesn&#8217;t enlarge the management surface like it does in typical component models where you own the implementation of the component.</p></li>
<li><p>Simple Deployment.  One of the biggest benefits of using the Cloud is the ease of deployment.  Partitioning the functional pieces of an application makes it thinner and easier to deploy.  With Cloud Components you can also setup development and staging instances that make it easy to simulate the production environment.  Then moving from one environment to another is simply a matter of configuration.</p></li>
<li><p>Better Security.  In most application architectures today there is one layer of security.  This would be like a bank without a vault.  There are a few ways into the bank that are wrapped with security (doors with locks) but as soon as someone has found a way in, they have access to everything.  With Cloud Components security can be more easily distributed to provide multiple layers of security.</p></li>
<li><p>Manageable costs.  With Cloud Components your costs can scale with your usage.  This means it&#8217;s easy to get started and grow rather than make large up-front investments.</p></li>
</ol>


<p>The Cloud Component Architecture may seem similar in ways to the old EJB and POJO Component Architectures because it is similar!  The wheel has not been reinvented, just improved.  The dream of Lego-style application assembly is now being realized because we&#8217;ve come full circle on some old ideas from twenty years ago (<a href="http://en.wikipedia.org/wiki/Corba">CORBA</a> anyone?).  This time around those ideas are reality thanks to the evolution of many independent pieces like REST, Polyglot, and the Share-Nothing pattern.  Cloud Components are the foundation of a new era of application development.  My only question is&#8230;  How long before we see the <a href="http://en.wikipedia.org/wiki/UDDI">UDDI</a> idea again?  ;)</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">James Ward</span></span>

      








  


<time datetime="2011-07-12T11:10:22-06:00" pubdate data-updated="true">Jul 12<span>th</span>, 2011</time>
      

<span class="categories">
  
    <a class='category' href='/categories/cloud/'>Cloud</a>, <a class='category' href='/categories/java/'>Java</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://jamesward.github.com/2011/07/12/architectural-evolution-from-middleware-to-the-cloud/" data-via="_JamesWard" data-counturl="http://jamesward.github.com/2011/07/12/architectural-evolution-from-middleware-to-the-cloud/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/2011/06/29/programming-summer-camp-2011/" title="Previous Post: Programming Summer Camp 2011">&laquo; Programming Summer Camp 2011</a>
      
      
        <a class="basic-alignment right" href="/2011/07/28/setup-play-framework-with-scala-in-intellij/" title="next Post: Setup Play Framework with Scala in IntelliJ">Setup Play Framework with Scala in IntelliJ &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    
<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating...</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("_JamesWard", 5, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/_JamesWard" class="twitter-follow-button" data-show-count="false">Follow @_JamesWard</a>
  
</section>


<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/101156657838073927919?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/jamesward">@jamesward</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jamesward',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2011/12/12/heroku-jug-tour-boulder-phoenix-portland/">Heroku JUG Tour: Boulder, Phoenix, & Portland</a>
      </li>
    
      <li class="post">
        <a href="/2011/12/11/tutorial-play-framework-jpa-json-jquery-heroku/">Tutorial: Play Framework, JPA, JSON, jQuery, & Heroku</a>
      </li>
    
      <li class="post">
        <a href="/2011/11/30/using-mongodb-for-a-java-web-apps-httpsession/">Using MongoDB for a Java Web App's HttpSession</a>
      </li>
    
      <li class="post">
        <a href="/2011/11/30/heroku-java-user-group-tour-columbus-and-orange-county/">Heroku Java User Group Tour: Columbus and Orange County</a>
      </li>
    
      <li class="post">
        <a href="/2011/11/29/heroku-preso-from-devoxx-2011/">Heroku Preso from Devoxx 2011</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - James Ward -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'jamesward';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
