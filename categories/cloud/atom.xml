<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cloud | James Ward]]></title>
  <link href="http://jamesward.github.com/categories/cloud/atom.xml" rel="self"/>
  <link href="http://jamesward.github.com/"/>
  <updated>2011-12-13T00:32:25-07:00</updated>
  <id>http://jamesward.github.com/</id>
  <author>
    <name><![CDATA[James Ward]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Video: Running Java Web Apps on the Cloud]]></title>
    <link href="http://jamesward.github.com/2011/09/14/video-running-java-web-apps-on-the-cloud/"/>
    <updated>2011-09-14T12:57:30-06:00</updated>
    <id>http://jamesward.github.com/2011/09/14/video-running-java-web-apps-on-the-cloud</id>
    <content type="html"><![CDATA[<p>Here is a quick screencast that shows how to instantly deploy Java web applications on the cloud with Heroku.</p>

<p>If you want more than a quick introduction check out a <a href="http://vimeo.com/28803302">recording of my presentation at JavaZone</a>.  And visit <a href="http://www.heroku.com/java">heroku.com/java</a> for more details on how to get started running Java apps on Heroku.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dreamforce 2011]]></title>
    <link href="http://jamesward.github.com/2011/08/10/dreamforce-2011/"/>
    <updated>2011-08-10T10:15:24-06:00</updated>
    <id>http://jamesward.github.com/2011/08/10/dreamforce-2011</id>
    <content type="html"><![CDATA[<p>I'm very excited to be presenting at <a href="http://www.salesforce.com/dreamforce/DF11/">Dreamforce</a> (salesforce.com's anual conference) this year!  On Thursday, September 1, from 1:15 pm to 2:15 pm I will be presenting:</p>

<blockquote><p><strong>Developing Java Cloud Apps</strong>
The cloud makes it easy to deploy highly scalable apps in an instant. This session will walk you through the steps to build your first Java app for the cloud. You'll also learn best practices for building mission-critical and horizontally scalable Java cloud apps.</p></blockquote>

<p>Then on Friday, September 2, from 10:00 am to 11:00 am I will be hosting a panel discussion:</p>

<blockquote><p><strong>Fireside Chat: Java on the Cloud</strong>
Come join the Java on the cloud product managers, architects, and experts for a casual, unscripted chat to find out how Java developers can best take advantage of the cloud. The session will be a mix of preselected and audience-provided questions. So bring all your tough, interesting, and quirky questions to this Fireside Chat.</p></blockquote>

<p>I hope to see you there!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architectural Evolution: From Middleware to The Cloud]]></title>
    <link href="http://jamesward.github.com/2011/07/12/architectural-evolution-from-middleware-to-the-cloud/"/>
    <updated>2011-07-12T11:10:22-06:00</updated>
    <id>http://jamesward.github.com/2011/07/12/architectural-evolution-from-middleware-to-the-cloud</id>
    <content type="html"><![CDATA[<p>You've heard it said that "all things old are new again."  That statement can certainly be applied to the current Cloud hype.  But each time the old becomes new it gets a bit better because of what was learned the last time around.  If we look back ten years at enterprise application development in Java things were quite different than they are today.  EJB was "the way" to build scalable systems from a vast abundance of components.  But things didn't work out as well as the vendors planned.</p>

<p><strong>EJB Component Architecture</strong></p>

<p>I remember back in the early days of enterprise Java everyone was talking about "Components."  Application complexity would be greatly reduced because there would be components for everything!  Need to connect your app to Exchange?  Well, there's a component for that.  Does your app need to send email?  No problem, there are twenty components for that!  Component marketplaces flourished with VC funding galore.</p>

<p>The official way to build reusable Java components became standardized as <em>Enterprise Java Beans</em> (EJB).  These "beans" could be accessed either locally or remotely!  Vendors led us to believe this was the panacea of Lego-style application development.  Just grab pieces from every-which place and hook them together.  Hooking the components together required a heavyweight "Middleware" server.  Here is what Monolithic Middleware with EJBs looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_j2ee.png" alt="" /></p>

<p>But the EJB Component Architecture didn't work.  Billions of dollars were spent on components and the middleware to tie them all together.  And now I bet you can't find a single person that doesn't regret going that route.  Why?  Three primary reasons...</p>

<ol>
<li><p>The programming model was too hard.  The EJB programming model consisted of too much boilerplate code ("solved" through code-gen tools like xdoclet).  EJB's also required configuration which was often middleware server-specific.  The EJB Component Architecture creates too many layers of indirection (<a href="http://java.sun.com/blueprints/corej2eepatterns/">Core J2EE Patterns</a> anyone?).</p></li>
<li><p>Scalability was too hard.  EJBs can either run inside your container (using what is called a "Local Interface") or somewhere else (a "Remote Interface").  Using Local Interfaces is fast but causes middleware to run into memory limits and scaling bloated app servers is challenging.  Using Remote Interfaces leads to massive serialization and routing overhead and whatever is on the remote end of the wire is still a pain to scale.</p></li>
<li><p>Deployment was too hard.  Remember the days when starting up an app server / middleware container took minutes not seconds?</p></li>
</ol>


<p>If you need further proof that the middleware model didn't work then just try to name one place you can still go to buy an EJB component today.  Obviously we needed another way to compose the parts of an application.</p>

<p><strong>POJO Component Architecture</strong></p>

<p>SpringSource deserves a lot of credit for pulling us out of the EJB muck.  They created a model where the application pieces are <em>Plain Old Java Objects</em> (POJOs) injected into an application.  This led to better testability, much easier deployment, and a much better programming model.  Essentially the revolution of Spring was to make all those app pieces injectable dependencies.  This was a huge step forward.  But there are still some limitations with this model that are currently being addressed by the next revolution.  The three primary challenges with the POJO Component Architecture are:</p>

<ol>
<li><p>Isolation is too hard.  It is now very easy to throw a bunch of components together into a single Web application ARchive (WAR).  But at some point all of these pieces being stacked on top of each other make our application brittle and difficult to piece together.  What do you do when the version of Hibernate you want to use requires a different version of an Apache Commons library than the version of XFire that you want to use?  Or when two libraries that your app needs actually require conflicting dependencies.  Sometimes isolating the pieces of an application is actually simpler than injecting them.  And unfortunately with POJOs you may not be able to easily switch from using a "Local Interface" to an external "Remote Interface" like you can with EJBs.</p></li>
<li><p>Polyglot is too hard.  The POJO components we use today in our systems are not inherently supportive of a Polyglot world where different parts of a system may be built using different technologies.  Suppose your system has a rules engine and you want to access it from a Java-based application and a Ruby-based application.  Today the only way to do that is to proxy that component and expose it through an easily serialization protocol (likely XML or JSON over HTTP).  This will likely add unnecessary complexity to your system.  When the high-level functional pieces of a system are technology-specific the entire system may be forced to use that technology or those pieces may exist multiple times to support the Polyglot nature of today's systems.</p></li>
<li><p>Scaling is still too hard.  As we continue to stack more pieces on top of each other it becomes harder to stick with simple, lightweight share-nothing architectures where each piece is individually horizontally scalable.</p></li>
</ol>


<p><strong>Cloud Component Architecture</strong></p>

<p>The emerging solution to the challenges we have faced with the EJB and POJO Component Architectures is the Cloud Component Architecture.  Instead of bundling components for things like search indexing, distributed caching, SMTP, and NoSQL data storage into your application those high level functions can instead be used as Cloud Components.  There are already numerous vendors providing "Component as a Service" products like MongoDB, Redis, CouchDB, Lucene Search, SMTP, and Memcache.</p>

<p>SMTP / outbound email is a simple example where the Cloud Component Architecture makes a lot of sense.  With the EJB and POJO Component Architectures I'd find a SMTP component that simply sends email.  Then configure my server to be able to send emails that aren't considered spam.  I'd also need to deal with constant blacklisting challenges and a larger management surface.  Or in a Cloud Component Architecture I could simply sign-up with one of the SMTP as a Service providers like <a href="http://www.authsmtp.com/">AuthSMTP</a> or <a href="http://sendgrid.com/">SendGrid</a> and then just use the Component as a Service.</p>

<p>Here is what the new Cloud Component Architecture for application composition looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_csa.png" alt="" /></p>

<p>The top six benefits of the Cloud Component Architecture are:</p>

<ol>
<li><p>Simple scalability.  By making each functional piece of an application an independent and lightweight service they can each be horizontally scaled without impacting the overall application architecture or configuration.  If you chose to use a vendor's Component as a Service then they will handle the scalability of those pieces.  Then you only need to scale a very thin web layer.  Composing Cloud Components also makes it easier to stick with a share-nothing architecture that is much easier to scale than the traditional architectures.</p></li>
<li><p>Rapid composition.  Cloud Components are flourishing!  Most of the basic building blocks that applications need are now provided "as a Service" by vendors who maintain and enhance them.  This is a much more erosion-resistant way to assemble applications when compared to the typical abandon-ware which is prevalent with many Java components.  Many of the emerging Cloud Components also provide client libraries for multiple platforms and RESTful APIs to support easy composition in Polyglot systems.</p></li>
<li><p>Reduced management surface.  With Cloud Components you can reduce the number of pieces you must manage down to only the stuff that is unique to your app.  Each Cloud Component you add doesn't enlarge the management surface like it does in typical component models where you own the implementation of the component.</p></li>
<li><p>Simple Deployment.  One of the biggest benefits of using the Cloud is the ease of deployment.  Partitioning the functional pieces of an application makes it thinner and easier to deploy.  With Cloud Components you can also setup development and staging instances that make it easy to simulate the production environment.  Then moving from one environment to another is simply a matter of configuration.</p></li>
<li><p>Better Security.  In most application architectures today there is one layer of security.  This would be like a bank without a vault.  There are a few ways into the bank that are wrapped with security (doors with locks) but as soon as someone has found a way in, they have access to everything.  With Cloud Components security can be more easily distributed to provide multiple layers of security.</p></li>
<li><p>Manageable costs.  With Cloud Components your costs can scale with your usage.  This means it's easy to get started and grow rather than make large up-front investments.</p></li>
</ol>


<p>The Cloud Component Architecture may seem similar in ways to the old EJB and POJO Component Architectures because it is similar!  The wheel has not been reinvented, just improved.  The dream of Lego-style application assembly is now being realized because we've come full circle on some old ideas from twenty years ago (<a href="http://en.wikipedia.org/wiki/Corba">CORBA</a> anyone?).  This time around those ideas are reality thanks to the evolution of many independent pieces like REST, Polyglot, and the Share-Nothing pattern.  Cloud Components are the foundation of a new era of application development.  My only question is...  How long before we see the <a href="http://en.wikipedia.org/wiki/UDDI">UDDI</a> idea again?  ;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started with Node.js on The Cloud]]></title>
    <link href="http://jamesward.github.com/2011/06/21/getting-started-with-node-js-on-the-cloud/"/>
    <updated>2011-06-21T10:21:22-06:00</updated>
    <id>http://jamesward.github.com/2011/06/21/getting-started-with-node-js-on-the-cloud</id>
    <content type="html"><![CDATA[<p>In my new job at salesforce.com I'm incredibly exited about getting into <a href="http://www.heroku.com">Heroku</a>, a Platform as a Service provider / Cloud Application Platform.  In a future blog post I'll provide more details on what Heroku is and how it works.  But if you are like me the first thing you want to do when learning a new technology is to take it for a test drive.  I decided to take my Heroku test drive using the <a href="http://devcenter.heroku.com/articles/node-js">recently announced Node.js support</a>.  I'm new to Node.js, but at least I know JavaScript.  Heroku also offers Ruby / Rails support but I don't know Ruby - yet.  So let me walk you through the steps I took (and that you can follow) to get started with Node.js on the Heroku Cloud.</p>

<p>(If you have already signed up for Heroku, installed the heroku command line client, and installed git then skip ahead to Step 6.)</p>

<p>Step 1) <a href="http://www.heroku.com/signup">Sign up for Heroku</a></p>

<p>Step 2) Install the heroku command line client</p>

<p>All of the Heroku management tasks are exposed through a RESTful API.  The easiest way to call those APIs is using the <a href="https://github.com/heroku/heroku">heroku open source command line</a> Ruby app.  To install the heroku command line I first had to install Ruby.  I'm on Ubuntu Linux so this process will be slightly different if you are on Windows or Mac but the <a href="http://devcenter.heroku.com/articles/quickstart">Heroku Dev Center</a> provides more information on how to do this on Windows and Mac.  On Ubuntu you can install Ruby with apt-get (or various other tools):</p>

<pre><code>sudo apt-get install ruby
</code></pre>

<p>Now <a href="http://rubygems.org/pages/download">download RubyGems</a>, unpack, and then install it:</p>

<pre><code>sudo ruby setup.rb
</code></pre>

<p>This installs the gem utility at /usr/bin/gem1.8 but I also created a symlink to it so I can run it with just the "gem" command:</p>

<pre><code>sudo ln -s /usr/bin/gem1.8 /usr/bin/gem
</code></pre>

<p>Now the heroku gem can be installed:</p>

<pre><code>sudo gem install heroku
</code></pre>

<p>Heroku should now run from the command line:</p>

<pre><code>heroku
</code></pre>

<p>You should see something like:</p>

<pre><code>Usage: heroku COMMAND [--app APP] [command-specific-options]

Primary help topics, type "heroku help TOPIC" for more details:

  auth      # authentication (login, logout)
  apps      # manage apps (create, destroy)
  ps        # manage processes (dynos, workers)
  run       # run one-off commands (console, rake)
  addons    # manage addon resources
  config    # manage app config vars
  releases  # view release history of an app
  domains   # manage custom domains
  logs      # display logs for an app
  sharing   # manage collaborators on an app

Additional topics:

  account      # manage heroku account options
  db           # manage the database for an app
  help         # list commands and display help
  keys         # manage authentication keys
  maintenance  # toggle maintenance mode
  pg           # manage heroku postgresql databases
  pgbackups    # manage backups of heroku postgresql databases
  plugins      # manage plugins to the heroku gem
  ssl          # manage ssl certificates for an app
  stack        # manage the stack for an app
  version      # display version
</code></pre>

<p>Step 3) Login to Heroku via the command line</p>

<p>You can verify that everything is setup correctly by logging into Heroku through the heroku command line.  This will save an API key into a ~/.heroku/credentials file.  That key will be used for authenticating you on subsequent requests. Just run the following command and enter your Heroku credentials:</p>

<pre><code>heroku auth:login
</code></pre>

<p>Step 4) Install git</p>

<p>The git tool is used to transfer apps to Heroku.  On Ubuntu I installed it by doing:</p>

<pre><code>sudo apt-get install git
</code></pre>

<p>Step 5) Setup your SSH key</p>

<p>Heroku uses SSH keys to authenticate you when you push files through git.  If you don't already have a SSH key then you will need to generate one (I used ssh-keygen).</p>

<p>Step 6) Create an app on Heroku</p>

<p>A new app needs to be provisioned on Heroku.  Since Heroku supports multiple application provisioning stacks you will need to tell it the stack you want to use, unless it's the default.  For Node.js we need to use the "cedar" stack which is not the default since it's still in beta.  To do that run:</p>

<pre><code>heroku create -s cedar
</code></pre>

<p>A default / random app name is automatically assigned to your app.  It will be somethingunique.herokuapp.com.  You can change the name either through the <a href="https://api.heroku.com/myapps">Heroku web admin</a> or via the command line:</p>

<pre><code>heroku apps:rename --app somethingunique hellofromnodejs
</code></pre>

<p>When the app was created your SSH key should have also been uploaded to Heroku for git access.  You can manage the keys associated with an app using the "heroku keys" commands.  Check out "heroku help keys" for more details.</p>

<p>Now that the app is provisioned it needs something to actually run!  So lets build a Node.js app and then upload it to Heroku.</p>

<p>Step 7) Install Node.js</p>

<p>On Ubuntu I installed Node.js through apt-get.  But first I had to add a PPA so that I could get the latest version.</p>

<pre><code>sudo apt-add-repository ppa:jerome-etienne/neoip
sudo apt-get update
sudo apt-get install nodejs
</code></pre>

<p>For other platforms, check out the <a href="http://nodejs.org/#download">Node.js Download page</a>.</p>

<p>Step 8) Create a Node.js app</p>

<p>I started by building a very simple "hello, world" Node.js app.  In a new project directory I created two new files.  First is the package.json file which specifies the app metadata and dependencies:</p>

<pre><code>{
  "name": "heroku_hello_world",
  "version": "0.0.1",
  "dependencies": {
    "express": "2.2.0"
  }
}
</code></pre>

<p>Then the actual app itself contained in a file named web.js:</p>

<pre><code>var express = require('express');

var app = express.createServer(express.logger());

app.get('/', function(request, response) {
  response.send('hello, world');
});

var port = process.env.PORT || 3000;
console.log("Listening on " + port);

app.listen(port);
</code></pre>

<p>This app simply maps requests to "/" to a function that sends a simple string back in the response.  You will notice that the port to listen on will first try to see if it has been specified through an environment variable and then fallback to port 3000.  This is important because Heroku can tell our app to run on a different port just by giving it an environment variable.</p>

<p>Step 9) Install the Node.js app dependencies</p>

<p>My simple Node.js app requires the <a href="http://expressjs.com/">Express Node.js library</a>.  In order to install Express, the <a href="http://npmjs.org/">Node Package Manager</a> (npm) is required.  Installing npm on Ubuntu was a bit trickey because I didn't feel the regular method followed good security practices.  So I followed the alternative install instructions by just cloning npm from github and then installed it from source:</p>

<pre><code>git clone git://github.com/isaacs/npm.git
cd npm
sudo make install
</code></pre>

<p>Now we can install the node dependencies into the local project directory.  Just run:</p>

<pre><code>npm install .
</code></pre>

<p>This uses the package.json to figure out what dependencies the app needs and then copies them into a "node_modules" directory.</p>

<p>Step 10) Try to run the app locally</p>

<p>From the command line run:</p>

<pre><code>node web.js
</code></pre>

<p>You should see "Listening on 3000" to indicate that the Node.js app is running!  Try to open it in your browser:
<a href="http://localhost:3000/">http://localhost:3000/</a></p>

<p>Hopefully you will see "hello, world".</p>

<p>Step 11) Create a Procfile</p>

<p>Heroku uses a "Procfile" to determine how to actually run your app.  Here I will just use a Procfile to tell Heroku what to run in the "web" process.  But the Procfile is really the foundation for telling Heroku how to run your stuff.  I won't go into detail here since Adam Wiggins has done a great <a href="http://blog.heroku.com/archives/2011/6/20/the_new_heroku_1_process_model_procfile/">blog post about the purpose and use of a Procfile</a>.  Create a file named "Procfile" in the project directory with the following contents:</p>

<pre><code>web: node web.js
</code></pre>

<p>This will instruct Heroku to run the web app using the node command and the web.js file as the main app.  Heroku can also run workers (non-web apps) but for now we will just deal with web processes.</p>

<p>Note: Once you have a Procfile you can <a href="http://devcenter.heroku.com/articles/procfile#developing_locally_with_foreman">run your application locally using Foreman</a>.  This allows you to simulate locally how Heroku will run your app based on your Procfile.</p>

<p>Step 12) Store the project files in a local git repo</p>

<p>In order to send the app to Heroku the files must be in a local git repository.  Of course you can also put them in a remote git repo (like github.com).  To create the local git repo run the following inside of your project directory:</p>

<pre><code>git init
</code></pre>

<p>Now add the three files you've created to the git repo:</p>

<pre><code>git add package.json Procfile web.js
</code></pre>

<p>Note: Make sure you don't add the node_modules directory to the git repo!  You can have git ignore it by creating a .gitignore file containing just "node_modules".</p>

<p>And commit the files to the local repo:</p>

<pre><code>git commit -m "initial commit"
</code></pre>

<p>Step 13) Push the project files to Heroku</p>

<p>Now we need to tell git about the remote repository on Heroku which we will push the app to.  When you provisioned the app on Heroku it gave you a web URL and a git URL.  If you don't have the git URL anymore you can determine it either by running the "heroku apps" command or by navigating to the <a href="https://api.heroku.com/myapps">app on heroku.com</a>.  The git URL will be something like "git@heroku.com:somethingunique.git" where the "somethingunique" is your app's name on Heroku.  Once you have the git URL add the remote repo:</p>

<pre><code>git remote add heroku git@heroku.com:somethingunique.git
</code></pre>

<p>Note: If we had created the git repo before creating the Heroku app then the heroku command line client would have automatically added the remote repo to your git configuration.</p>

<p>Now you can push your app to Heroku!  Just run:</p>

<pre><code>git push heroku master
</code></pre>

<p>You should see something like:</p>

<pre><code>Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 617 bytes, done.
Total 6 (delta 0), reused 6 (delta 0)

-----&gt; Heroku receiving push
-----&gt; Node.js app detected
-----&gt; Vendoring node 0.4.7
-----&gt; Installing dependencies with npm 1.0.8
       express@2.2.0 ./node_modules/express 
       ├── mime@1.2.2
       ├── connect@1.4.4
       └── qs@0.1.0
       Dependencies installed
-----&gt; Discovering process types
       Procfile declares types -&gt; web
-----&gt; Compiled slug size is 3.1MB
-----&gt; Launching... done, v4
       http://somethingunique.herokuapp.com deployed to Heroku

To git@heroku.com:somethingunique.git
 * [new branch]      master -&gt; master
</code></pre>

<p>Now you should be able to connect to your app in the browser!  You can also get some diagnostic information out of the heroku command line.  To see your app logs (provisioning, management, scaling, and system out messages) run:</p>

<pre><code>heroku logs
</code></pre>

<p>To see your app processes run:</p>

<pre><code>heroku ps
</code></pre>

<p>And best of all, if you want to add more Dynos* just run:</p>

<pre><code>heroku scale web=2
</code></pre>

<ul>
<li>Dynos are the isolated containers that run your web and other processes.  They are managed by the Heroku Dyno Manifold.  <a href="http://devcenter.heroku.com/articles/dynos">Learn more about Dynos</a>.</li>
</ul>


<p>That increases the number of Dynos running the app from one to two.  Automatically Heroku will distribute the load across those two Dynos, detect dead Dynos, restart them, etc!  That is seriously easy app scalability!</p>

<p>There is much more to Heroku and I'll be continuing to write about it here.  But in the meantime, check out all of the great docs in the <a href="http://devcenter.heroku.com/">Heroku Dev Center</a>.  And please let me know if you have any questions or problems.  Thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Adventures on The Cloud]]></title>
    <link href="http://jamesward.github.com/2011/06/05/new-adventures-on-the-cloud/"/>
    <updated>2011-06-05T17:47:25-06:00</updated>
    <id>http://jamesward.github.com/2011/06/05/new-adventures-on-the-cloud</id>
    <content type="html"><![CDATA[<p>When I started doing professional software development almost 15 years ago I was focused on the server-side.  I started with Perl / CGI web apps - some of which are still in production today.  Then I dove into Java web development with Java Web Server 1.0, Struts, JBoss, Tomcat and many other game changing technologies.</p>

<p>In 2004 I started getting into Macromedia Flex.  I was amazed at how easy it was to retrieve and nicely render data from a Java back-end.  In 2005 I began evangelizing Flex + Java.  Following the acquisition of Macromedia by Adobe, Flex has really flourished.  Adobe Flex is now the dominant RIA technology and it has been so fun to be a part of that!</p>

<p>Over the past seven years I've had so many great adventures on the client-side, but when a new opportunity on the server-side came my way I couldn't pass it up.  Starting June 6th I'll be stepping back into the Java world to evangelize the Cloud for Salesforce.com.  I'm excited to dive into some of the emerging Java/JVM technologies like Scala, Play Framework, and Clojure!</p>

<p>This change is certainly bittersweet for me.  Flex continues to make app development easier.  With things like Android support in Flex 4.5 and iOS support coming soon, the future of Flex is bright.  I've been very privileged to be a part of the Flex community for the past seven years. This group of passionate and creative developers have taught me so many new things.  Learning how to do runtime bytecode modification and co-creating <a href="http://www.jamesward.com/2011/04/26/introducing-mixing-loom-runtime-actionscript-bytecode-modification/">Mixing Loom</a> has certainly been one of the highlights!</p>

<p>As I begin this new adventure on the Cloud I'm excited about what lies ahead for Flex and for the Cloud.  Both continue to help us developers build better software.  I've hopefully helped you learn how to build great UIs with Flex.  Now I will help you learn how to build solid and scalable back-ends on the Cloud!</p>
]]></content>
  </entry>
  
</feed>
