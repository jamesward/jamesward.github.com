--- 
layout: post
title: "Learning Scala: Function Literals"
published: true
meta: 
  _edit_last: "1"
  custom_permalink: 2011/10/17/learning-scala-function-literals
tags: 
- Scala
type: post
status: publish
---
I've gradually been learning Scala over the past few months and I really have been enjoying it.  For me Scala is like Shakespeare.  It seems familiar and totally foreign at the same time.  I don't enjoy Shakespeare plays nearly as much as someone who has taken the time to learn the language of Shakespeare.  Some have interpreted Scala being "familiar yet totally foreign" as Scala being "hard" but I'd say it's just different.  With Scala there is probably more about programming that I need to unlearn than to learn.  My perspectives on programming languages have been shaped by the ones I've used most (Java, ActionScript, etc).  And now my perspecives are being reshaped.  It might take some time and work but I believe that using Scala will soon be very enjoyable for me.

Ok, enough fluff lets see some code!

My friend <a href="http://www.mslinn.com/blog/">Mike Slinn</a> and I have been learning <a href="https://github.com/jdegoes/blueeyes">BlueEyes</a> - a lightweight Scala web 3.0 framework.  We encountered a piece of Scala that seemed strange and unfamiliar to us:
<pre lang="scala">
get { request =>
  // do something
}
</pre>

To a Java developer like me this was pretty foreign.  I was able to understand this after I encountered <em>Function Literals</em> in the free <a href="http://typesafe.com/resources/scala-for-the-impatient">Scala for the Impatient</a> book.  So let me break down what is happening here with another example.  Lets start with writing a regular function that takes a <em>Char</em> parameter and returns a <em>Boolean</em> if the provided <em>Char</em> was the letter "l":
<pre lang="scala">
def lls(p: Char): Boolean = { p == 'l' }
</pre>

This is a pretty straight forward (albeit slightly verbose) function definition.  Oh, and I should mention that if you <a href="http://www.scala-lang.org/downloads">download Scala</a> and run the REPL (a command line interpreter), then you can actually try this code yourself.  To start the Scala REPL just run the "scala" command.

Ok, lets test out that function:
<pre lang="scala">
lls('p') // outputs false
lls('l') // outputs true
</pre>

That should all be somewhat familiar looking for a Java developer.  But here is where things begin to look more foreign.  The <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.StringOps">StringOps</a> class in Scala has a <em>count</em> method that takes something very peculiar looking.  From the ScalaDoc:
<pre lang="scala">
def count (p: (Char) â‡’ Boolean): Int
</pre>

That is saying that <em>count</em> takes a function as an argument.  Scala is this wonderful blend of Object Oriented and Functional so this is instantly strange to the Java developer in me.  In this case the function that <em>count</em> is taking must have a single parameter of type <em>Char</em> and then return a <em>Boolean</em>.  So lets try to pass the <em>lls</em> function to <em>count</em> on a <em>StringOps</em> instance.  Somehow with Scala's Type Inference system we can just use a regular double-quoted <em>String</em> and Scala will figure out that we need a <em>StringOps</em> instead.  So let's create a <em>StringOps</em> object and call count on it passing it the <em>lls</em> function:
<pre lang="scala">
"Hello".count(lls) // outputs 2
</pre>

I could have assigned "Hello" to a variable and done it that way but opted to just make the <em>count</em> call without assigning it.  So <em>count</em> correctly took the <em>lls</em> function and used it to count the number of "l" <em>Chars</em> in the <em>String</em> (or <em>SpringOps</em>).  That all works as expected.

But, there is another (prettier) way to do the same thing:
<pre lang="scala">
"Hello" count lls // outputs 2
</pre>

We can drop the dot operator and parenthesis and everything still works.  But there is another way...  Instead of referencing a function we can just pass the function definition directly into the count method:
<pre lang="scala">
"Hello" count { p:Char => p == 'l' } // outputs 2
</pre>

This is a <strong>Function Literal</strong> - or as Dick Wall tells me, a predicate in this case since it returns a <em>Boolean</em>.  A Function Literal is a short way to define a function that takes only one parameter and returns what is needed by whatever the function is being passed to.  In this case the function parameter is still a Char with an identifier of "p" and the function body simply compares "p" with the 'l' <em>Char</em>.  In Scala the value of the last statement in a function is returned.  So the <em>Boolean</em> is returned from the function.  That type is inferred.  And the <em>Char</em> type declaration on "p" could have been left off and inferred making it:
<pre lang="scala">
"Hello" count { p => p == 'l' } // outputs 2
</pre>

Now that code I started with is making a lot more sense!

But it doesn't stop there.  With Scala we can be even more concise:
<pre lang="scala">
"Hello" count { _ == 'l' } // still outputs 2
</pre>

Now I must admit that I haven't really learned what that "_" thing does.  So I don't totally understand this code yet.  But like learning to understand Shakespeare we have to take it one step at a time.  I will leave that to another day and maybe another blog post.  I hope this was helpful for other Scala noobs.  Let me know what you think and if you have any questions.
