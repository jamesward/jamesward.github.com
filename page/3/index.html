
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>James Ward</title>
  <meta name="author" content="James Ward">

  
  <meta name="description" content="A couple of questions [1, 2] on StackOverflow.com led me to look into how we can send file uploads in a Play Framework application to Amazon S3 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jamesward.github.com/page/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="James Ward" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-784803-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">James Ward</a></h1>
  
    <h2>Heroku | Java | Scala | Cloud | Open Source | Linux</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jamesward.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/about-james-ward">About James Ward</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/09/13/sending-play-framework-file-uploads-to-amazon-s3/">Sending Play Framework File Uploads to Amazon S3</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-13T08:00:39-06:00" pubdate data-updated="true">Sep 13<span>th</span>, 2011</time>
        
         | <a href="/2011/09/13/sending-play-framework-file-uploads-to-amazon-s3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>A couple of questions [<a href="http://stackoverflow.com/questions/7314106/handling-file-uploads-in-play-framework-on-heroku/7334400">1</a>, <a href="http://stackoverflow.com/questions/7258965/store-blob-in-heroku-or-similar-cloud-services">2</a>] on StackOverflow.com led me to look into how we can send file uploads in a Play Framework application to <a href="http://aws.amazon.com/s3/">Amazon S3</a> instead of the local disk.  For applications running on Heroku this is especially important because the local disk is not persistent.  Persistent disk storage makes it hard to scale apps.  Instead of using the file system, it&#8217;s better to use an external service which is independent of the web tier.</p>

<p>While at JavaZone I sat down with <a href="https://twitter.com/peterhilton">Peter Hilton</a> and <a href="https://twitter.com/nicolasleroux">Nicolas Leroux</a> to come up with a way to handle this.  It only took us 30 minutes to get something working - start to finish - including setup time.  This is what is so compelling about Play Framework.  I&#8217;ve built many Java web apps and it always seems like I spend too much time setting up builds, IDEs, and plumbing.  With Play we were setup and working on the actual app in less than a minute.  After getting everything working locally it took another minute to actually run it on the cloud with Heroku.  The combination of Play Framework and Heroku is a developer&#8217;s dream for fast-paced development and deployment.</p>

<p>All of the code for the sample application is on github:
<a href="https://github.com/jamesward/plays3upload">https://github.com/jamesward/plays3upload</a></p>

<p>The basics of what we did was this:</p>

<pre><code>public static void doUpload(String comment, File attachment)
{
    AWSCredentials awsCredentials = new BasicAWSCredentials(System.getenv("AWS_ACCESS_KEY"), System.getenv("AWS_SECRET_KEY"));
    AmazonS3 s3Client = new AmazonS3Client(awsCredentials);
    s3Client.createBucket(BUCKET_NAME);
    String s3Key = UUID.randomUUID().toString();
    s3Client.putObject(BUCKET_NAME, s3Key, attachment);
    Document doc = new Document(comment, s3Key, attachment.getName());
    doc.save();
    listUploads();
}
</code></pre>

<p>This uses a JPA Entity to persist the metadata about the file upload (for some reason we named it &#8216;Document&#8217;) and a reference to the file&#8217;s key in S3.  But there was a sexier way, so my co-worker <a href="https://github.com/tkral">Tim Kral</a> added a new <a href="https://github.com/jamesward/plays3upload/blob/master/app/s3/storage/S3Blob.java">S3Blob</a> type that could be used directly in the JPA Entity.  Tim also cleaned up the configuration to make it more Play Framework friendly.  So lets walk through the entire app so you can see the pieces.</p>

<p>The <a href="https://github.com/jamesward/plays3upload/blob/master/app/models/Document.java">app/models/Document.java</a> JPA Entity has three fields - the file being of type S3Blob:</p>

<pre><code>package models;

import javax.persistence.Entity;

import play.db.jpa.Model;
import s3.storage.S3Blob;

@Entity
public class Document extends Model
{
    public String fileName;
    public S3Blob file;
    public String comment;
}
</code></pre>

<p>The S3Blob is now doing all of the work to talk to the Amazon S3 APIs to persist and fetch the actual file.</p>

<p>Configuration of S3 is done by adding a plugin to the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/play.plugins">conf/play.plugins</a> file:</p>

<pre><code>0: s3.storage.S3Plugin
</code></pre>

<p>The <a href="https://github.com/jamesward/plays3upload/blob/master/app/s3/storage/S3Blob.java">S3Plugin</a> handles reading the AWS credentials from the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/application.conf">conf/application.conf</a> file, setting up the S3Client, and creating the S3 Bucket - if necessary.</p>

<p>In the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/application.conf">conf/application.conf</a> file, environment variables are mapped to the configuration parameters in the Play application:</p>

<pre><code>aws.access.key=${AWS_ACCESS_KEY}
aws.secret.key=${AWS_SECRET_KEY}
s3.bucket=${S3_BUCKET}
</code></pre>

<p>The values could be entered into the conf file directly but I used environment variables so they would be easier to change when running on Heroku.</p>

<p>The Amazon AWS API must be added to the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/dependencies.yml">conf/dependencies.yml</a> file:</p>

<pre><code>require:
    - play
    - com.amazonaws -&gt; aws-java-sdk 1.2.7
</code></pre>

<p>The sample application has a new controller in <a href="https://github.com/jamesward/plays3upload/blob/master/app/controllers/Files.java">app/controllers/Files.java</a> that can display the upload form, handle the file upload, display the list of uploads, and handle the file download:</p>

<pre><code>package controllers;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.List;

import models.Document;
import play.libs.MimeTypes;
import play.mvc.Controller;
import s3.storage.S3Blob;

public class Files extends Controller
{

  public static void uploadForm()
  {
    render();
  }

  public static void doUpload(File file, String comment) throws FileNotFoundException
  {
    final Document doc = new Document();
    doc.fileName = file.getName();
    doc.comment = comment;
    doc.file = new S3Blob();
    doc.file.set(new FileInputStream(file), MimeTypes.getContentType(file.getName()));

    doc.save();
    listUploads();
  }

  public static void listUploads()
  {
    List&lt;document&gt; docs = Document.findAll();
    render(docs);
  }

  public static void downloadFile(long id)
  {
    final Document doc = Document.findById(id);
    notFoundIfNull(doc);
    response.setContentTypeIfNotSet(doc.file.type());
    renderBinary(doc.file.get(), doc.fileName);
  }

}
</code></pre>

<p>The <strong>uploadForm()</strong> method just causes the <a href="https://github.com/jamesward/plays3upload/blob/master/app/views/Files/uploadForm.html">app/views/Files/uploadForm.html</a> page to be displayed.</p>

<p>The <strong>doUpload()</strong> method handles the file upload and creates a new <strong>Document</strong> object that stores the file in S3 and the comment in a database.  After storing the file and comment it runs the <strong>listUploads()</strong> method. Of-course a database must be configured in the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/application.conf">conf/application.conf</a> file.  For running on Heroku the database is provided and just needs to be configured with the following values:</p>

<pre><code>db=${DATABASE_URL}
jpa.dialect=org.hibernate.dialect.PostgreSQLDialect
jpa.ddl=update
</code></pre>

<p>The <strong>listUploads()</strong> method fetches all <strong>Document</strong> objects out of the database and then displays the <a href="https://github.com/jamesward/plays3upload/blob/master/app/views/Files/listUploads.html">apps/views/files/listUploads.html</a> page.</p>

<p>If a user selects a file from the list then the <strong>downloadFile()</strong> method is called which finds the file in S3 and sends it back to the client as a binary stream.  An alternative to this would be to get the file directly from Amazon using either the <a href="file:///home/jamesw/aws-java-sdk-1.2.6/documentation/javadoc/com/amazonaws/services/s3/AmazonS3Client.html#generatePresignedUrl(java.lang.String,%20java.lang.String,%20java.util.Date">S3 generatePresignedUrl()</a>) method or via <a href="http://aws.amazon.com/cloudfront/">CloudFront</a>.</p>

<p>Finally in the <a href="https://github.com/jamesward/plays3upload/blob/master/conf/routes">conf/routes</a> file, requests to &#8220;/&#8221; have been mapped to the <strong>Files.uploadForm()</strong> method:</p>

<pre><code>GET     /                                       Files.uploadForm
</code></pre>

<p>That&#8217;s it!  Now we have an easy way to persist file uploads in an external system!</p>

<h2>Running the Play! app on Heroku</h2>

<p>If you&#8217;d like to run this example on Heroku, here is what you need to do:</p>

<p>Install the heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>.</p>

<p>Login to Heroku via the command line:</p>

<pre><code>heroku auth:login
</code></pre>

<p>Clone the git repo:</p>

<pre><code>git clone git@github.com:jamesward/plays3upload.git
</code></pre>

<p>Move to the project dir:</p>

<pre><code>cd plays3upload
</code></pre>

<p>Create the app on Heroku:</p>

<pre><code>heroku create -s cedar
</code></pre>

<p>Set the AWS environment vars on Heroku:</p>

<pre><code>heroku config:add AWS_ACCESS_KEY="YOUR_AWS_ACCESS_KEY" AWS_SECRET_KEY="YOUR_AWS_SECRET_KEY" S3_BUCKET="AN_AWS_UNIQUE_BUCKET_ID"
</code></pre>

<p>Upload the app to Heroku:</p>

<pre><code>git push heroku master
</code></pre>

<p>Open the app in the browser:</p>

<pre><code>heroku open
</code></pre>

<p>Let me know if you have any questions or problems.  And thanks to Peter, Nicolas, and Tim for helping with this!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/08/31/java-and-play-framework-on-the-cloud-at-javazone/">Java and Play Framework on the Cloud at JavaZone</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-31T18:22:10-06:00" pubdate data-updated="true">Aug 31<span>st</span>, 2011</time>
        
         | <a href="/2011/08/31/java-and-play-framework-on-the-cloud-at-javazone/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Next week I am speaking in Oslo at <a href="http://jz11.java.no/">JavaZone</a> about deploying Java and <a href="http://www.playframework.org">Play! Framework</a> apps on the Cloud.  I submitted the session before <a href="http://www.jamesward.com/2011/08/25/heroku-adds-java-support">Heroku for Java</a> was available so I had to obfuscate the title and description.  If you are at JavaZone then I hope to see you at my &#8221;<a href="http://javazone.no/incogito10/events/JavaZone%202011/sessions#f4ae4b01-1d5b-43fc-b635-af26388ddbf3">Deploying Apps on Heroku</a>&#8221; session!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/08/29/getting-started-with-play-framework-on-heroku/">Getting Started With Play Framework on Heroku</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-29T09:11:28-06:00" pubdate data-updated="true">Aug 29<span>th</span>, 2011</time>
        
         | <a href="/2011/08/29/getting-started-with-play-framework-on-heroku/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Last week Heroku announced that <a href="http://www.jamesward.com/2011/08/25/heroku-adds-java-support">you can now run Java apps on Heroku</a>.  Today <a href="http://blog.heroku.com/archives/2011/8/29/play/">Heroku announced</a> that you can also easily run <a href="http://www.playframework.org">Play Framework</a> apps on Heroku!  Here&#8217;s a quick guide to getting started with Play! on Heroku:</p>

<ol>
<li><p>Install the heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>.</p></li>
<li><p>Install <a href="http://git-scm.com/">git</a> and setup your SSH key</p></li>
<li><p><a href="http://www.playframework.org/download">Install Play! version 1.2.3</a></p></li>
<li><p>Login to Heroku from the command line:</p></li>
</ol>


<pre><code>heroku auth:login
</code></pre>

<ol>
<li>Create a new Play! app:</li>
</ol>


<pre><code>play new play_hello_world
cd play_hello_world
</code></pre>

<ol>
<li>Run the app locally to test it:</li>
</ol>


<pre><code>play run --%production
</code></pre>

<ol>
<li>Create a git repo, add the files, and commit:</li>
</ol>


<pre><code>git init
git add app conf lib public test
git commit -m init
</code></pre>

<ol>
<li>Create a new app on Heroku:</li>
</ol>


<pre><code>heroku create -s cedar
</code></pre>

<ol>
<li>Push the app to Heroku:</li>
</ol>


<pre><code>git push heroku master
</code></pre>

<ol>
<li>Open the app in your browser:</li>
</ol>


<pre><code>heroku open
</code></pre>

<p>That&#8217;s it!  If you want to learn more about Heroku, check out the <a href="https://github.com/heroku/java-workbook">Heroku for Java Workbook</a> and the <a href="http://devcenter.heroku.com/">Heroku Dev Center</a>.  And if you are at Dreamforce 2011 then check out <a href="http://geeks.aretotally.in/">Felipe Oliveira&#8217;s</a> session on &#8220;Introducing Play! Framework: Painless Java and Scala Web Applications&#8221; on Wednesday at 3:30pm.</p>

<p>Let me know what you think and if you have any questions.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/08/25/heroku-adds-java-support/">Heroku Adds Java Support</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-25T15:23:53-06:00" pubdate data-updated="true">Aug 25<span>th</span>, 2011</time>
        
         | <a href="/2011/08/25/heroku-adds-java-support/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Today <a href="http://blog.heroku.com/archives/2011/8/25/java/">Heroku announced</a> that Java is now supported on the Heroku Cloud Application Platform!  This is incredibly exciting news and I&#8217;m very lucky to be a Heroku for Java Developer Evangelist!</p>

<p>Joining salesforce.com and jumping into the the Java Cloud space holds some nostalgia for me.  When I began using Java in 1997 I was working at an ISP in Denver.  We did the regular web hosting thing, but when the first Java Servlet engines (like Java Web Server 1.0) came out, I created the &#8220;wantjava.com&#8221; hosting service.  Things were really nasty at first.  We could only run one instance of the JWS on a server so I came up with a really bad way to do &#8220;multi-tenancy&#8221;.  I setup a cron job to rsync the customers&#8217; .class files into the server&#8217;s webapp and then restart the server.  Customers had to email me to get a servlet added to the web.xml file.  Uggg&#8230;  I feel like I need to go to confession for this.  But it worked and as the Servlet containers improved we quickly migrated to a more sustainable model.</p>

<p>Now thirteen years later I am privileged to once again be part of Java on the Cloud.  But this time around things are so much easier, better, and sexier!  Heroku is a leading the way in a new generation of application deployment that is making things much better for us Java developers.</p>

<h2>What is Heroku?</h2>

<p>Shortly I will dive into how you can run Java on Heroku, but first, what is Heroku?  From my perspective, Heroku is a <a href="http://blog.heroku.com/archives/2011/8/3/polyglot_platform/">Polyglot Cloud Application Platform</a>.  Heroku provides us a way to run Ruby, Node.js, Clojure, and Java applications on a managed, scalable, and multi-tenant system.  Heroku also provides <a href="http://addons.heroku.com">numerous add-ons</a> that help us make the <a href="http://www.jamesward.com/2011/07/12/architectural-evolution-from-middleware-to-the-cloud">shift from monolithic middleware to Cloud Components</a>.  Another way to say it is:</p>

<p>**</p>

<pre><code>Heroku = Polyglot + Platform as a Service (PaaS) + Cloud Components
</code></pre>

<p>**</p>

<p>It is very exciting to see these three things coming together!  With Polyglot I can choose the right tool for the job.  With PaaS I don&#8217;t have to think about managing operating systems, scalability, failover, etc.  And with the Cloud Component Architecture I can keep my app thin and focused on what is unique to the problem it needs to solve.  Heroku brings these models together as a cloud application platform.</p>

<h2>Running Java Apps on Heroku</h2>

<p>Heroku can run any Java app that runs in OpenJDK 6.  Today Heroku uses Maven to create a &#8221;<a href="http://devcenter.heroku.com/articles/slug-compiler">slug</a>&#8221; for Java apps.  That slug can then be loaded onto one or more &#8221;<a href="http://devcenter.heroku.com/articles/dynos">dynos</a>&#8221;.  You can tell a dyno to execute / start a Java app from the command line and you can also use a &#8221;<a href="http://devcenter.heroku.com/articles/procfile">Procfile</a>&#8221; to provide a command that will auto-start for each instance of a specific dyno type.  Web dynos are able to listen on a port and will receive HTTP traffic through a load balancer that is automatically setup for each app.  With that background knowledge, lets dive into code!</p>

<p>For Dreamforce 2011, I (with the help of a few co-workers) put together a <a href="http://github.com/heroku/java-workbook">Heroku for Java Workbook</a>.  The Workbook provides detailed instructions on how to create web apps, connect to a database, setup worker processes, use the Redis to Go Heroku add-on, and use Spring Roo on Heroku.  But if you are anxious to get started and don&#8217;t need as much hand-holding, here is a quick and very simple walk through of how to run Java on Heroku:</p>

<ol>
<li><p>Install the heroku command line client on <a href="http://toolbelt.herokuapp.com/linux/readme">Linux</a>, <a href="http://toolbelt.herokuapp.com/osx/download">Mac</a>, or <a href="http://toolbelt.herokuapp.com/windows/download">Windows</a>.</p></li>
<li><p>Install <a href="http://git-scm.com/">git</a> and setup your ssh key</p></li>
<li><p>Install <a href="http://maven.apache.org">Maven</a></p></li>
<li><p>Login to Heroku from the command line:</p></li>
</ol>


<pre><code>heroku auth:login
</code></pre>

<ol>
<li><p>Create a new project directory and move into it:</p></li>
</ol>


<pre><code>mkdir helloherokujava
cd helloherokujava
</code></pre>

<ol>
<li><p>Create a Maven build file named <code>pom.xml</code> containing:</p></li>
</ol>


<pre><code>&lt;project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
    &lt;modelversion&gt;4.0.0&lt;/modelversion&gt;
    &lt;groupid&gt;foo&lt;/groupid&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;helloherokujava&lt;/name&gt;
    &lt;artifactid&gt;helloherokujava&lt;/artifactid&gt;
&lt;/project&gt;
</code></pre>

<ol>
<li><p>Create a Java source directory:</p></li>
</ol>


<pre><code>mkdir -p src/main/java
</code></pre>

<ol>
<li><p>Create a new Java class in the <code>src/main/java</code> directory named <code>Hello.java</code> containing:</p></li>
</ol>


<pre><code>public class Hello
{
  public static void main(String[] args)
  {
    System.out.println("hello, world");
  }
}
</code></pre>

<ol>
<li><p>Compile the class:</p></li>
</ol>


<pre><code>mvn compile
</code></pre>

<ol>
<li><p>Run the class locally:</p></li>
</ol>


<pre><code>java -cp target/classes Hello
</code></pre>

<ol>
<li><p>Create a local git repo, add the <code>pom.xml</code> file &amp; <code>src</code> dir, and commit the files:</p></li>
</ol>


<pre><code>git init
git add pom.xml src
git commit -m init
</code></pre>

<ol>
<li><p>Create a new app on Heroku using the Cedar stack:</p></li>
</ol>


<pre><code>heroku create -s cedar
</code></pre>

<ol>
<li><p>Upload your app to Heroku:</p></li>
</ol>


<pre><code>git push heroku master
</code></pre>

<p>Heroku will create a slug for your app.</p>

<ol>
<li><p>Run the app on Heroku:</p></li>
</ol>


<pre><code>heroku run "java -cp target/classes Hello"
</code></pre>

<p>Heroku will start a new dyno with your slug and then run the specified command.</p>

<p>You just ran Java on the cloud!  Obviously this is a very simple example.  But I like to start new things with the simplest thing that could possibly work.  Now that you have that working there is more to learn and much more power to harness!</p>

<h2>Next Steps</h2>

<ul>
<li><p>Go through the <a href="http://github.com/heroku/java-workbook">Heroku for Java Workbook</a></p></li>
<li><p>Go through the articles on the <a href="http://devcenter.heroku.com/articles/java">Heroku Dev Center</a></p></li>
<li><p>Ask questions about Heroku on <a href="http://stackoverflow.com">StackOverflow</a></p></li>
<li><p>Keep watching here for many more blogs about Java on Heroku</p></li>
</ul>


<p>Have fun and please let me know if you have any questions about Heroku.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/08/23/war-less-java-web-apps/">WAR-less Java Web Apps</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-23T08:59:30-06:00" pubdate data-updated="true">Aug 23<span>rd</span>, 2011</time>
        
         | <a href="/2011/08/23/war-less-java-web-apps/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Have you ever thought about why in Java we package up web apps into WAR files (or WAR directory structures)? It certainly is a convenient way to move an application and its dependencies from one place to another. But wouldn&#8217;t it be nice if everything could just stay in its original location and there wouldn&#8217;t be any moving of files around? Wouldn&#8217;t it also be nice if you specified your required version of Jetty or Tomcat just like you do with every other dependency? The WAR-less approach is one that is catching on as emerging Java web frameworks like <a href="http://www.playframework.org/">Play!</a> ditch the WAR files. With standard Java web apps we can also ditch the WAR files by simply launching an embedded Jetty or Tomcat server. Let&#8217;s give this a try and see how it goes.</p>

<p>For this experiment I&#8217;m going to use Maven and Jetty. This will still use the same standard source structure for a WAR file (<em>src/main/java</em>, <em>src/main/webapp</em>, etc). The major difference is that I will actually startup Jetty using a good-old <em>static void main</em>. This is similar to using the <em>jetty:run</em> goal but will allow us to have the same exact setup in development and in production. The static stuff will be in <em>src/main/webapp</em>, the compiled classes will be in target/classes, and the dependencies will be right were Maven downloaded them to. First, here is a little Java class (<em>src/main/java/foo/Main.java</em>) that sets up a Jetty server and starts it:</p>

<pre><code>package foo;

import java.io.File;
import java.net.URL;
import java.util.jar.Attributes;
import java.util.jar.JarFile;

import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.handler.*;
import org.eclipse.jetty.util.StringUtil;
import org.eclipse.jetty.webapp.WebAppContext;

public class Main
{

  public static void main(String[] args) throws Exception
  {
    String webappDirLocation = "src/main/webapp/";

    Server server = new Server(8080);
    WebAppContext root = new WebAppContext();

    root.setContextPath("/");
    root.setDescriptor(webappDirLocation + "/WEB-INF/web.xml");
    root.setResourceBase(webappDirLocation);

    root.setParentLoaderPriority(true);

    server.setHandler(root);

    server.start();
    server.join();
  }
}
</code></pre>

<p>As you can see, Main just references the webapp directory so I don&#8217;t have to copy the stuff from there to another place. Next I have a little test servlet (<em>src/main/java/foo/HelloServlet.java</em>):</p>

<pre><code>package foo;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class HelloServlet extends HttpServlet
{   

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
  {
    PrintWriter out = resp.getWriter();
    out.println("hello, world");
    out.close();
  }
}
</code></pre>

<p>And now the <em>web.xml</em> file (<em>src/main/webapp/WEB-INF/web.xml</em>):</p>

<pre><code>&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemalocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;foo.HelloServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>

<p>And finally a <em>pom.xml</em> file that specifies Jetty as a dependency and provides an easy way to run the Main class:</p>

<pre><code>&lt;project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

  &lt;modelversion&gt;4.0.0&lt;/modelversion&gt;
  &lt;groupid&gt;com.jamesward&lt;/groupid&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;warless_java_web_app&lt;/name&gt;
  &lt;artifactid&gt;warless_java_web_app&lt;/artifactid&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;properties&gt;
    &lt;jettyversion&gt;7.3.1.v20110307&lt;/jettyversion&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupid&gt;org.eclipse.jetty&lt;/groupid&gt;
      &lt;artifactid&gt;jetty-server&lt;/artifactid&gt;
      &lt;version&gt;${jettyVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupid&gt;org.eclipse.jetty&lt;/groupid&gt;
      &lt;artifactid&gt;jetty-webapp&lt;/artifactid&gt;
      &lt;version&gt;${jettyVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupid&gt;org.eclipse.jetty&lt;/groupid&gt;
      &lt;artifactid&gt;jetty-servlet&lt;/artifactid&gt;
      &lt;version&gt;${jettyVersion}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupid&gt;org.codehaus.mojo&lt;/groupid&gt;
        &lt;artifactid&gt;exec-maven-plugin&lt;/artifactid&gt;
        &lt;version&gt;1.2&lt;/version&gt;
        &lt;configuration&gt;
          &lt;mainclass&gt;foo.Main&lt;/mainclass&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>

<p>And now simply run:</p>

<pre><code>mvn compile exec:java
</code></pre>

<p>Maven compiles my Java classes into <em>target/classes</em> and then the <em>exec:java</em> goal runs the Main which finds the other WAR assets in the <em>src/main/webapp</em> directory. If you have been following along, make a request to <a href="http://localhost:8080/">http://localhost:8080/</a> to verify that it works (which it should).</p>

<p>There are two alternatives to running Jetty from Maven. You can use the Maven appassembler plugin to create start scripts containing the correct <em>CLASSPATH</em> references and then launch Main class using the generated scripts. Or you can use the Maven assembly or shade plugin to create a JAR containing the application and all of its dependencies.</p>

<p>Here is an example section of a <em>pom.xml</em> file for using the appassembler plugin:</p>

<pre><code>  &lt;plugin&gt;
    &lt;groupid&gt;org.codehaus.mojo&lt;/groupid&gt;
    &lt;artifactid&gt;appassembler-maven-plugin&lt;/artifactid&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;configuration&gt;
      &lt;assembledirectory&gt;target&lt;/assembledirectory&gt; 
      &lt;generaterepository&gt;false&lt;/generaterepository&gt;
      &lt;programs&gt;
        &lt;program&gt;
          &lt;mainclass&gt;foo.Main&lt;/mainclass&gt;
          &lt;name&gt;main&lt;/name&gt;
        &lt;/program&gt;
      &lt;/programs&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;assemble&lt;/goal&gt;
        &lt;/goals&gt;
      &lt;/execution&gt;          
    &lt;/executions&gt;
  &lt;/plugin&gt;
</code></pre>

<p>To generate the start scripts simply run:</p>

<pre><code>mvn install
</code></pre>

<p>Then to run the script set the REPO environment variable to your Maven repository:</p>

<pre><code>export REPO=~/.m2/repository
</code></pre>

<p>And then simply run the script:</p>

<pre><code>sh target/bin/main
</code></pre>

<p>All of the code for this example is on github.com:
<a href="https://github.com/jamesward/warless_java_web_apps">https://github.com/jamesward/warless_java_web_apps</a></p>

<p>To make all of this even easier, Jetty has a Maven archetype for generating everything for you. To create a new project containing this setup run:</p>

<pre><code>mvn archetype:generate -DarchetypeGroupId=org.mortbay.jetty.archetype -DarchetypeArtifactId=jetty-archetype-assembler -DarchetypeVersion=7.5.0-SNAPSHOT
</code></pre>

<p>And now you are ready to build a WAR-less Java web app!</p>

<p>This setup is really the bare minimum required to handle web resource and servlet requests you will need to do a little more work if you want to add JSP support. Find out more about this in the <a href="http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty#Embedding_JSP">Jetty documentation</a>.</p>

<p>So&#8230; What do you think about Java Web apps without WAR files &amp; WAR packaging? I&#8217;d love to hear your thoughts!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/08/10/dreamforce-2011/">Dreamforce 2011</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-10T10:15:24-06:00" pubdate data-updated="true">Aug 10<span>th</span>, 2011</time>
        
         | <a href="/2011/08/10/dreamforce-2011/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I&#8217;m very excited to be presenting at <a href="http://www.salesforce.com/dreamforce/DF11/">Dreamforce</a> (salesforce.com&#8217;s anual conference) this year!  On Thursday, September 1, from 1:15 pm to 2:15 pm I will be presenting:</p>

<blockquote><p><strong>Developing Java Cloud Apps</strong>
The cloud makes it easy to deploy highly scalable apps in an instant. This session will walk you through the steps to build your first Java app for the cloud. You&#8217;ll also learn best practices for building mission-critical and horizontally scalable Java cloud apps.</p></blockquote>

<p>Then on Friday, September 2, from 10:00 am to 11:00 am I will be hosting a panel discussion:</p>

<blockquote><p><strong>Fireside Chat: Java on the Cloud</strong>
Come join the Java on the cloud product managers, architects, and experts for a casual, unscripted chat to find out how Java developers can best take advantage of the cloud. The session will be a mix of preselected and audience-provided questions. So bring all your tough, interesting, and quirky questions to this Fireside Chat.</p></blockquote>

<p>I hope to see you there!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/07/28/setup-play-framework-with-scala-in-intellij/">Setup Play Framework With Scala in IntelliJ</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-28T08:13:31-06:00" pubdate data-updated="true">Jul 28<span>th</span>, 2011</time>
        
         | <a href="/2011/07/28/setup-play-framework-with-scala-in-intellij/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Yesterday at the <a href="https://sites.google.com/site/programmingsummercamp/">Programming Summer Camp</a> a group of us were working together to learn the <a href="http://www.playframework.org/">Play Framework</a>.  Once we were able to get the basics working we wanted to get everything working in <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>.  Due to a lack of good documentation on the subject things did not go smoothly until we figured out the right &#8220;magical incantations&#8221;.  We did eventually get it working so I wanted to document the steps we took.</p>

<ol>
<li>Add Scala support to Play:</li>
</ol>


<pre><code>play install scala
</code></pre>

<ol>
<li>Create a new Play project with Scala support:</li>
</ol>


<pre><code>play new foo --with scala
</code></pre>

<ol>
<li>Have Play create an IntelliJ Module Descriptor:</li>
</ol>


<pre><code>play idealize foo
</code></pre>

<ol>
<li>Run the app:</li>
</ol>


<pre><code>play run foo
</code></pre>

<ol>
<li><p>Access the app in a browser to generate some source files we will use later:
<a href="http://localhost:9000">http://localhost:9000</a></p></li>
<li><p>Shutdown the Play server.</p></li>
<li><p>Currently the Play Scala Module (version 0.9.1) only supports Scala 2.8.1 so <a href="http://www.scala-lang.org/node/165">download</a> and extract that version.</p></li>
<li><p>Create a new project (from scratch) in IntelliJ.  The location should be the same as the directory where the Play project was created.  Un-check the &#8220;Create module&#8221; option.<img src="http://www.jamesward.com/wp/uploads/2011/07/1.png" alt="" /></p></li>
<li><p>In the Project Structure window, with &#8220;Modules&#8221; selected, click the &#8220;+&#8221; button to add a new module to the project.</p></li>
<li><p>Select the &#8220;Import existing module&#8221; option and then point it to the generated .iml file.<img src="http://www.jamesward.com/wp/uploads/2011/07/2.png" alt="" /></p></li>
<li><p>With the module now selected, select the content root block for the module (mine is /home/jamesw/projects/foo).  Then select the &#8220;tmp/generated&#8221; directory in the tree on the right and press the &#8220;Sources&#8221; button.  The HTML template pages are converted to .scala source files by Play and we need these source files to be included in the project along with the regular source files in the app directory.<img src="http://www.jamesward.com/wp/uploads/2011/07/3.png" alt="" /></p></li>
<li><p>Select &#8220;Global Libraries&#8221; in the Platform Settings on the left and add a new Java Library named &#8220;scala-compiler-2.8.1&#8221;.  Then press the &#8220;Attach Classes&#8230;&#8221; button and navigate to the &#8220;lib&#8221; directory in your Scala 2.8.1 directory.  Then select the &#8220;scala-compiler.jar&#8221; and &#8220;scala-library.jar&#8221; files.</p></li>
<li><p>Add another Global Library named &#8220;scala-library-2.8.1&#8221; containing the &#8220;scala-dbc.jar&#8221;, &#8220;scala-library.jar&#8221;, and &#8220;scala-swing.jar&#8221; files.<img src="http://www.jamesward.com/wp/uploads/2011/07/6.png" alt="" /></p></li>
<li><p>Press the &#8220;Apply&#8221; button to save the Global Libraries configuration.</p></li>
<li><p>Select &#8220;Modules&#8221; and then the &#8220;Dependencies&#8221; tab.  Press the &#8220;Add&#8230;&#8221; button and select &#8220;Library&#8221; to add a new library to the module.  Select &#8220;scala-library-2.8.1&#8221; and then press the &#8220;Add Selected&#8221; button to add it to the Dependencies.<img src="http://www.jamesward.com/wp/uploads/2011/07/7.png" alt="" /></p></li>
<li><p>Select the &#8220;Scala&#8221; Facet in the module and set the Compiler library to the &#8220;scala-compiler-2.8.1&#8221; option.<img src="http://www.jamesward.com/wp/uploads/2011/07/8.png" alt="" /></p></li>
<li><p>Save the Project Structure by pressing the &#8220;Ok&#8221; button.  Make sure the project now builds without any errors.</p></li>
<li><p>To run the Play server from IntelliJ a new Run Configuration must be configured.  To create a new Run Configuration select &#8220;Run&#8221; from the main IntelliJ menu and then select &#8220;Edit Configurations&#8221;.</p></li>
<li><p>Press the &#8220;+&#8221; button and select &#8220;Application&#8221; from the list of Run Configuration types.</p></li>
<li><p>Set the name to &#8220;Play Server&#8221;.</p></li>
<li><p>Set the Main class to &#8220;play.server.Server&#8221;.</p></li>
<li><p>Set the VM Parameters to:</p></li>
</ol>


<pre><code>-Dapplication.path="."
</code></pre>

<ol>
<li><p>De-select the &#8220;Make&#8221; option in the &#8220;Before Launch&#8221; section.</p></li>
<li><p>Press the &#8220;Ok&#8221; button to save the configuration. <img src="http://www.jamesward.com/wp/uploads/2011/07/9.png" alt="" /></p></li>
<li><p>Run the Play Server by selecting &#8220;Run&#8221; from the &#8220;Run&#8221; IntelliJ menu and verify that the application still works by opening the application in a browser.</p></li>
</ol>


<p>It is so much easier to figure this stuff out with a group of people.  That is just one of the many reasons why the Programming Summer Camp is a great event!</p>

<p>Let me know if you have any questions or problems.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/07/12/architectural-evolution-from-middleware-to-the-cloud/">Architectural Evolution: From Middleware to the Cloud</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-12T11:10:22-06:00" pubdate data-updated="true">Jul 12<span>th</span>, 2011</time>
        
         | <a href="/2011/07/12/architectural-evolution-from-middleware-to-the-cloud/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>You&#8217;ve heard it said that &#8220;all things old are new again.&#8221;  That statement can certainly be applied to the current Cloud hype.  But each time the old becomes new it gets a bit better because of what was learned the last time around.  If we look back ten years at enterprise application development in Java things were quite different than they are today.  EJB was &#8220;the way&#8221; to build scalable systems from a vast abundance of components.  But things didn&#8217;t work out as well as the vendors planned.</p>

<p><strong>EJB Component Architecture</strong></p>

<p>I remember back in the early days of enterprise Java everyone was talking about &#8220;Components.&#8221;  Application complexity would be greatly reduced because there would be components for everything!  Need to connect your app to Exchange?  Well, there&#8217;s a component for that.  Does your app need to send email?  No problem, there are twenty components for that!  Component marketplaces flourished with VC funding galore.</p>

<p>The official way to build reusable Java components became standardized as <em>Enterprise Java Beans</em> (EJB).  These &#8220;beans&#8221; could be accessed either locally or remotely!  Vendors led us to believe this was the panacea of Lego-style application development.  Just grab pieces from every-which place and hook them together.  Hooking the components together required a heavyweight &#8220;Middleware&#8221; server.  Here is what Monolithic Middleware with EJBs looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_j2ee.png" alt="" /></p>

<p>But the EJB Component Architecture didn&#8217;t work.  Billions of dollars were spent on components and the middleware to tie them all together.  And now I bet you can&#8217;t find a single person that doesn&#8217;t regret going that route.  Why?  Three primary reasons&#8230;</p>

<ol>
<li><p>The programming model was too hard.  The EJB programming model consisted of too much boilerplate code (&#8220;solved&#8221; through code-gen tools like xdoclet).  EJB&#8217;s also required configuration which was often middleware server-specific.  The EJB Component Architecture creates too many layers of indirection (<a href="http://java.sun.com/blueprints/corej2eepatterns/">Core J2EE Patterns</a> anyone?).</p></li>
<li><p>Scalability was too hard.  EJBs can either run inside your container (using what is called a &#8220;Local Interface&#8221;) or somewhere else (a &#8220;Remote Interface&#8221;).  Using Local Interfaces is fast but causes middleware to run into memory limits and scaling bloated app servers is challenging.  Using Remote Interfaces leads to massive serialization and routing overhead and whatever is on the remote end of the wire is still a pain to scale.</p></li>
<li><p>Deployment was too hard.  Remember the days when starting up an app server / middleware container took minutes not seconds?</p></li>
</ol>


<p>If you need further proof that the middleware model didn&#8217;t work then just try to name one place you can still go to buy an EJB component today.  Obviously we needed another way to compose the parts of an application.</p>

<p><strong>POJO Component Architecture</strong></p>

<p>SpringSource deserves a lot of credit for pulling us out of the EJB muck.  They created a model where the application pieces are <em>Plain Old Java Objects</em> (POJOs) injected into an application.  This led to better testability, much easier deployment, and a much better programming model.  Essentially the revolution of Spring was to make all those app pieces injectable dependencies.  This was a huge step forward.  But there are still some limitations with this model that are currently being addressed by the next revolution.  The three primary challenges with the POJO Component Architecture are:</p>

<ol>
<li><p>Isolation is too hard.  It is now very easy to throw a bunch of components together into a single Web application ARchive (WAR).  But at some point all of these pieces being stacked on top of each other make our application brittle and difficult to piece together.  What do you do when the version of Hibernate you want to use requires a different version of an Apache Commons library than the version of XFire that you want to use?  Or when two libraries that your app needs actually require conflicting dependencies.  Sometimes isolating the pieces of an application is actually simpler than injecting them.  And unfortunately with POJOs you may not be able to easily switch from using a &#8220;Local Interface&#8221; to an external &#8220;Remote Interface&#8221; like you can with EJBs.</p></li>
<li><p>Polyglot is too hard.  The POJO components we use today in our systems are not inherently supportive of a Polyglot world where different parts of a system may be built using different technologies.  Suppose your system has a rules engine and you want to access it from a Java-based application and a Ruby-based application.  Today the only way to do that is to proxy that component and expose it through an easily serialization protocol (likely XML or JSON over HTTP).  This will likely add unnecessary complexity to your system.  When the high-level functional pieces of a system are technology-specific the entire system may be forced to use that technology or those pieces may exist multiple times to support the Polyglot nature of today&#8217;s systems.</p></li>
<li><p>Scaling is still too hard.  As we continue to stack more pieces on top of each other it becomes harder to stick with simple, lightweight share-nothing architectures where each piece is individually horizontally scalable.</p></li>
</ol>


<p><strong>Cloud Component Architecture</strong></p>

<p>The emerging solution to the challenges we have faced with the EJB and POJO Component Architectures is the Cloud Component Architecture.  Instead of bundling components for things like search indexing, distributed caching, SMTP, and NoSQL data storage into your application those high level functions can instead be used as Cloud Components.  There are already numerous vendors providing &#8220;Component as a Service&#8221; products like MongoDB, Redis, CouchDB, Lucene Search, SMTP, and Memcache.</p>

<p>SMTP / outbound email is a simple example where the Cloud Component Architecture makes a lot of sense.  With the EJB and POJO Component Architectures I&#8217;d find a SMTP component that simply sends email.  Then configure my server to be able to send emails that aren&#8217;t considered spam.  I&#8217;d also need to deal with constant blacklisting challenges and a larger management surface.  Or in a Cloud Component Architecture I could simply sign-up with one of the SMTP as a Service providers like <a href="http://www.authsmtp.com/">AuthSMTP</a> or <a href="http://sendgrid.com/">SendGrid</a> and then just use the Component as a Service.</p>

<p>Here is what the new Cloud Component Architecture for application composition looks like:
<img src="http://www.jamesward.com/wp/uploads/2011/07/MiddlewaretoCloudServices_csa.png" alt="" /></p>

<p>The top six benefits of the Cloud Component Architecture are:</p>

<ol>
<li><p>Simple scalability.  By making each functional piece of an application an independent and lightweight service they can each be horizontally scaled without impacting the overall application architecture or configuration.  If you chose to use a vendor&#8217;s Component as a Service then they will handle the scalability of those pieces.  Then you only need to scale a very thin web layer.  Composing Cloud Components also makes it easier to stick with a share-nothing architecture that is much easier to scale than the traditional architectures.</p></li>
<li><p>Rapid composition.  Cloud Components are flourishing!  Most of the basic building blocks that applications need are now provided &#8220;as a Service&#8221; by vendors who maintain and enhance them.  This is a much more erosion-resistant way to assemble applications when compared to the typical abandon-ware which is prevalent with many Java components.  Many of the emerging Cloud Components also provide client libraries for multiple platforms and RESTful APIs to support easy composition in Polyglot systems.</p></li>
<li><p>Reduced management surface.  With Cloud Components you can reduce the number of pieces you must manage down to only the stuff that is unique to your app.  Each Cloud Component you add doesn&#8217;t enlarge the management surface like it does in typical component models where you own the implementation of the component.</p></li>
<li><p>Simple Deployment.  One of the biggest benefits of using the Cloud is the ease of deployment.  Partitioning the functional pieces of an application makes it thinner and easier to deploy.  With Cloud Components you can also setup development and staging instances that make it easy to simulate the production environment.  Then moving from one environment to another is simply a matter of configuration.</p></li>
<li><p>Better Security.  In most application architectures today there is one layer of security.  This would be like a bank without a vault.  There are a few ways into the bank that are wrapped with security (doors with locks) but as soon as someone has found a way in, they have access to everything.  With Cloud Components security can be more easily distributed to provide multiple layers of security.</p></li>
<li><p>Manageable costs.  With Cloud Components your costs can scale with your usage.  This means it&#8217;s easy to get started and grow rather than make large up-front investments.</p></li>
</ol>


<p>The Cloud Component Architecture may seem similar in ways to the old EJB and POJO Component Architectures because it is similar!  The wheel has not been reinvented, just improved.  The dream of Lego-style application assembly is now being realized because we&#8217;ve come full circle on some old ideas from twenty years ago (<a href="http://en.wikipedia.org/wiki/Corba">CORBA</a> anyone?).  This time around those ideas are reality thanks to the evolution of many independent pieces like REST, Polyglot, and the Share-Nothing pattern.  Cloud Components are the foundation of a new era of application development.  My only question is&#8230;  How long before we see the <a href="http://en.wikipedia.org/wiki/UDDI">UDDI</a> idea again?  ;)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/06/29/programming-summer-camp-2011/">Programming Summer Camp 2011</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-29T15:14:16-06:00" pubdate data-updated="true">Jun 29<span>th</span>, 2011</time>
        
         | <a href="/2011/06/29/programming-summer-camp-2011/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Over the past few years I&#8217;ve attended a bunch of geek/coder events in the Colorado Mountains.  It always surprises me how much I can learn by getting away, being around some really smart people, and writing code with them.  So I&#8217;m incredibly excited to be attending <a href="https://sites.google.com/site/programmingsummercamp/">The Programming Summer Camp 2011</a> this summer in Crested Butte, Colorado!</p>

<p>At the summer camp you can choose which campsite to hangout in.  Or if you want, you can create your own campsite!  I&#8217;ll probably spend most of my time in the Scala campsite.  But I look forward to mingling in some of the other campsites as well.</p>

<p>It&#8217;s like I&#8217;m a kid again - getting all excited about going to camp!  But I really hope you all can join me July 25 - 29 in Crested Butte, Colorado for <a href="https://sites.google.com/site/programmingsummercamp/">The Programming Summer Camp 2011</a>!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/06/21/getting-started-with-node-js-on-the-cloud/">Getting Started With Node.js on the Cloud</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-21T10:21:22-06:00" pubdate data-updated="true">Jun 21<span>st</span>, 2011</time>
        
         | <a href="/2011/06/21/getting-started-with-node-js-on-the-cloud/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In my new job at salesforce.com I&#8217;m incredibly exited about getting into <a href="http://www.heroku.com">Heroku</a>, a Platform as a Service provider / Cloud Application Platform.  In a future blog post I&#8217;ll provide more details on what Heroku is and how it works.  But if you are like me the first thing you want to do when learning a new technology is to take it for a test drive.  I decided to take my Heroku test drive using the <a href="http://devcenter.heroku.com/articles/node-js">recently announced Node.js support</a>.  I&#8217;m new to Node.js, but at least I know JavaScript.  Heroku also offers Ruby / Rails support but I don&#8217;t know Ruby - yet.  So let me walk you through the steps I took (and that you can follow) to get started with Node.js on the Heroku Cloud.</p>

<p>(If you have already signed up for Heroku, installed the heroku command line client, and installed git then skip ahead to Step 6.)</p>

<p>Step 1) <a href="http://www.heroku.com/signup">Sign up for Heroku</a></p>

<p>Step 2) Install the heroku command line client</p>

<p>All of the Heroku management tasks are exposed through a RESTful API.  The easiest way to call those APIs is using the <a href="https://github.com/heroku/heroku">heroku open source command line</a> Ruby app.  To install the heroku command line I first had to install Ruby.  I&#8217;m on Ubuntu Linux so this process will be slightly different if you are on Windows or Mac but the <a href="http://devcenter.heroku.com/articles/quickstart">Heroku Dev Center</a> provides more information on how to do this on Windows and Mac.  On Ubuntu you can install Ruby with apt-get (or various other tools):</p>

<pre><code>sudo apt-get install ruby
</code></pre>

<p>Now <a href="http://rubygems.org/pages/download">download RubyGems</a>, unpack, and then install it:</p>

<pre><code>sudo ruby setup.rb
</code></pre>

<p>This installs the gem utility at /usr/bin/gem1.8 but I also created a symlink to it so I can run it with just the &#8220;gem&#8221; command:</p>

<pre><code>sudo ln -s /usr/bin/gem1.8 /usr/bin/gem
</code></pre>

<p>Now the heroku gem can be installed:</p>

<pre><code>sudo gem install heroku
</code></pre>

<p>Heroku should now run from the command line:</p>

<pre><code>heroku
</code></pre>

<p>You should see something like:</p>

<pre><code>Usage: heroku COMMAND [--app APP] [command-specific-options]

Primary help topics, type "heroku help TOPIC" for more details:

  auth      # authentication (login, logout)
  apps      # manage apps (create, destroy)
  ps        # manage processes (dynos, workers)
  run       # run one-off commands (console, rake)
  addons    # manage addon resources
  config    # manage app config vars
  releases  # view release history of an app
  domains   # manage custom domains
  logs      # display logs for an app
  sharing   # manage collaborators on an app

Additional topics:

  account      # manage heroku account options
  db           # manage the database for an app
  help         # list commands and display help
  keys         # manage authentication keys
  maintenance  # toggle maintenance mode
  pg           # manage heroku postgresql databases
  pgbackups    # manage backups of heroku postgresql databases
  plugins      # manage plugins to the heroku gem
  ssl          # manage ssl certificates for an app
  stack        # manage the stack for an app
  version      # display version
</code></pre>

<p>Step 3) Login to Heroku via the command line</p>

<p>You can verify that everything is setup correctly by logging into Heroku through the heroku command line.  This will save an API key into a ~/.heroku/credentials file.  That key will be used for authenticating you on subsequent requests. Just run the following command and enter your Heroku credentials:</p>

<pre><code>heroku auth:login
</code></pre>

<p>Step 4) Install git</p>

<p>The git tool is used to transfer apps to Heroku.  On Ubuntu I installed it by doing:</p>

<pre><code>sudo apt-get install git
</code></pre>

<p>Step 5) Setup your SSH key</p>

<p>Heroku uses SSH keys to authenticate you when you push files through git.  If you don&#8217;t already have a SSH key then you will need to generate one (I used ssh-keygen).</p>

<p>Step 6) Create an app on Heroku</p>

<p>A new app needs to be provisioned on Heroku.  Since Heroku supports multiple application provisioning stacks you will need to tell it the stack you want to use, unless it&#8217;s the default.  For Node.js we need to use the &#8220;cedar&#8221; stack which is not the default since it&#8217;s still in beta.  To do that run:</p>

<pre><code>heroku create -s cedar
</code></pre>

<p>A default / random app name is automatically assigned to your app.  It will be somethingunique.herokuapp.com.  You can change the name either through the <a href="https://api.heroku.com/myapps">Heroku web admin</a> or via the command line:</p>

<pre><code>heroku apps:rename --app somethingunique hellofromnodejs
</code></pre>

<p>When the app was created your SSH key should have also been uploaded to Heroku for git access.  You can manage the keys associated with an app using the &#8220;heroku keys&#8221; commands.  Check out &#8220;heroku help keys&#8221; for more details.</p>

<p>Now that the app is provisioned it needs something to actually run!  So lets build a Node.js app and then upload it to Heroku.</p>

<p>Step 7) Install Node.js</p>

<p>On Ubuntu I installed Node.js through apt-get.  But first I had to add a PPA so that I could get the latest version.</p>

<pre><code>sudo apt-add-repository ppa:jerome-etienne/neoip
sudo apt-get update
sudo apt-get install nodejs
</code></pre>

<p>For other platforms, check out the <a href="http://nodejs.org/#download">Node.js Download page</a>.</p>

<p>Step 8) Create a Node.js app</p>

<p>I started by building a very simple &#8220;hello, world&#8221; Node.js app.  In a new project directory I created two new files.  First is the package.json file which specifies the app metadata and dependencies:</p>

<pre><code>{
  "name": "heroku_hello_world",
  "version": "0.0.1",
  "dependencies": {
    "express": "2.2.0"
  }
}
</code></pre>

<p>Then the actual app itself contained in a file named web.js:</p>

<pre><code>var express = require('express');

var app = express.createServer(express.logger());

app.get('/', function(request, response) {
  response.send('hello, world');
});

var port = process.env.PORT || 3000;
console.log("Listening on " + port);

app.listen(port);
</code></pre>

<p>This app simply maps requests to &#8220;/&#8221; to a function that sends a simple string back in the response.  You will notice that the port to listen on will first try to see if it has been specified through an environment variable and then fallback to port 3000.  This is important because Heroku can tell our app to run on a different port just by giving it an environment variable.</p>

<p>Step 9) Install the Node.js app dependencies</p>

<p>My simple Node.js app requires the <a href="http://expressjs.com/">Express Node.js library</a>.  In order to install Express, the <a href="http://npmjs.org/">Node Package Manager</a> (npm) is required.  Installing npm on Ubuntu was a bit trickey because I didn&#8217;t feel the regular method followed good security practices.  So I followed the alternative install instructions by just cloning npm from github and then installed it from source:</p>

<pre><code>git clone git://github.com/isaacs/npm.git
cd npm
sudo make install
</code></pre>

<p>Now we can install the node dependencies into the local project directory.  Just run:</p>

<pre><code>npm install .
</code></pre>

<p>This uses the package.json to figure out what dependencies the app needs and then copies them into a &#8220;node_modules&#8221; directory.</p>

<p>Step 10) Try to run the app locally</p>

<p>From the command line run:</p>

<pre><code>node web.js
</code></pre>

<p>You should see &#8220;Listening on 3000&#8221; to indicate that the Node.js app is running!  Try to open it in your browser:
<a href="http://localhost:3000/">http://localhost:3000/</a></p>

<p>Hopefully you will see &#8220;hello, world&#8221;.</p>

<p>Step 11) Create a Procfile</p>

<p>Heroku uses a &#8220;Procfile&#8221; to determine how to actually run your app.  Here I will just use a Procfile to tell Heroku what to run in the &#8220;web&#8221; process.  But the Procfile is really the foundation for telling Heroku how to run your stuff.  I won&#8217;t go into detail here since Adam Wiggins has done a great <a href="http://blog.heroku.com/archives/2011/6/20/the_new_heroku_1_process_model_procfile/">blog post about the purpose and use of a Procfile</a>.  Create a file named &#8220;Procfile&#8221; in the project directory with the following contents:</p>

<pre><code>web: node web.js
</code></pre>

<p>This will instruct Heroku to run the web app using the node command and the web.js file as the main app.  Heroku can also run workers (non-web apps) but for now we will just deal with web processes.</p>

<p>Note: Once you have a Procfile you can <a href="http://devcenter.heroku.com/articles/procfile#developing_locally_with_foreman">run your application locally using Foreman</a>.  This allows you to simulate locally how Heroku will run your app based on your Procfile.</p>

<p>Step 12) Store the project files in a local git repo</p>

<p>In order to send the app to Heroku the files must be in a local git repository.  Of course you can also put them in a remote git repo (like github.com).  To create the local git repo run the following inside of your project directory:</p>

<pre><code>git init
</code></pre>

<p>Now add the three files you&#8217;ve created to the git repo:</p>

<pre><code>git add package.json Procfile web.js
</code></pre>

<p>Note: Make sure you don&#8217;t add the node_modules directory to the git repo!  You can have git ignore it by creating a .gitignore file containing just &#8220;node_modules&#8221;.</p>

<p>And commit the files to the local repo:</p>

<pre><code>git commit -m "initial commit"
</code></pre>

<p>Step 13) Push the project files to Heroku</p>

<p>Now we need to tell git about the remote repository on Heroku which we will push the app to.  When you provisioned the app on Heroku it gave you a web URL and a git URL.  If you don&#8217;t have the git URL anymore you can determine it either by running the &#8220;heroku apps&#8221; command or by navigating to the <a href="https://api.heroku.com/myapps">app on heroku.com</a>.  The git URL will be something like &#8220;git@heroku.com:somethingunique.git&#8221; where the &#8220;somethingunique&#8221; is your app&#8217;s name on Heroku.  Once you have the git URL add the remote repo:</p>

<pre><code>git remote add heroku git@heroku.com:somethingunique.git
</code></pre>

<p>Note: If we had created the git repo before creating the Heroku app then the heroku command line client would have automatically added the remote repo to your git configuration.</p>

<p>Now you can push your app to Heroku!  Just run:</p>

<pre><code>git push heroku master
</code></pre>

<p>You should see something like:</p>

<pre><code>Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 617 bytes, done.
Total 6 (delta 0), reused 6 (delta 0)

-----&gt; Heroku receiving push
-----&gt; Node.js app detected
-----&gt; Vendoring node 0.4.7
-----&gt; Installing dependencies with npm 1.0.8
       express@2.2.0 ./node_modules/express 
        mime@1.2.2
        connect@1.4.4
        qs@0.1.0
       Dependencies installed
-----&gt; Discovering process types
       Procfile declares types -&gt; web
-----&gt; Compiled slug size is 3.1MB
-----&gt; Launching... done, v4
       http://somethingunique.herokuapp.com deployed to Heroku

To git@heroku.com:somethingunique.git
 * [new branch]      master -&gt; master
</code></pre>

<p>Now you should be able to connect to your app in the browser!  You can also get some diagnostic information out of the heroku command line.  To see your app logs (provisioning, management, scaling, and system out messages) run:</p>

<pre><code>heroku logs
</code></pre>

<p>To see your app processes run:</p>

<pre><code>heroku ps
</code></pre>

<p>And best of all, if you want to add more Dynos* just run:</p>

<pre><code>heroku scale web=2
</code></pre>

<ul>
<li>Dynos are the isolated containers that run your web and other processes.  They are managed by the Heroku Dyno Manifold.  <a href="http://devcenter.heroku.com/articles/dynos">Learn more about Dynos</a>.</li>
</ul>


<p>That increases the number of Dynos running the app from one to two.  Automatically Heroku will distribute the load across those two Dynos, detect dead Dynos, restart them, etc!  That is seriously easy app scalability!</p>

<p>There is much more to Heroku and I&#8217;ll be continuing to write about it here.  But in the meantime, check out all of the great docs in the <a href="http://devcenter.heroku.com/">Heroku Dev Center</a>.  And please let me know if you have any questions or problems.  Thanks!</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("_JamesWard", 5, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/_JamesWard" class="twitter-follow-button" data-show-count="false">Follow @_JamesWard</a>
  
</section>


<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/101156657838073927919?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/jamesward">@jamesward</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jamesward',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2011/12/12/heroku-jug-tour-boulder-phoenix-portland/">Heroku JUG Tour: Boulder, Phoenix, & Portland</a>
      </li>
    
      <li class="post">
        <a href="/2011/12/11/tutorial-play-framework-jpa-json-jquery-heroku/">Tutorial: Play Framework, JPA, JSON, jQuery, & Heroku</a>
      </li>
    
      <li class="post">
        <a href="/2011/11/30/using-mongodb-for-a-java-web-apps-httpsession/">Using MongoDB for a Java Web App&#8217;s HttpSession</a>
      </li>
    
      <li class="post">
        <a href="/2011/11/30/heroku-java-user-group-tour-columbus-and-orange-county/">Heroku Java User Group Tour: Columbus and Orange County</a>
      </li>
    
      <li class="post">
        <a href="/2011/11/29/heroku-preso-from-devoxx-2011/">Heroku Preso from Devoxx 2011</a>
      </li>
    
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - James Ward -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'jamesward';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
